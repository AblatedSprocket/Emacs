# -*- mode: org; coding: utf-8; -*-
#+TODO: DISABLED | ACTIVE
#+STARTUP: indent
* General Configuration
** ACTIVE Built-In Emacs
These are the general purpose functions I've found or made over my time with Emacs. I have found =beginning-of-line-or-indentation= and =whack-whitespace= very useful as keybindings, but I almost never use =switch-to-previous-buffer=. I actually haven't used =apropos= much, but after investigating it while writing this, I've discovered it is a very useful tool for discovering! It functions similarly to the =C-h= keybindings, but it's a bit more accessible in my opinion. The other big thing I want to point out is I disabled minor modes showing up in the modeline using the =mode-line-modes= setting.
#+BEGIN_SRC emacs-lisp
(defun beginning-of-line-or-indentation ()
  "Move to beginning of line or indentation."
  (interactive)
  (if (bolp)
      (back-to-indentation)
    (beginning-of-line)))
(defun switch-to-previous-buffer()
  "Switch to previously open buffer.
Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))
(defun whack-whitespace (arg)
    "Deletes all white space from point to the next word. With prefix ARG delete across newlines as well. The only danger in this is that you don't have to actually be at the end of a word to make it work.  It skips over to the next whitespace and then whacks it all to the next word."
      (interactive "P")
      (let ((regexp (if arg "[ \t\n]+" "[ \t]+")))
        (re-search-forward regexp nil t)
        (replace-match "" nil nil)))
(set-cursor-color "#000000")
(set-default 'truncate-lines t)
(set-face-attribute 'default nil :font "Inconsolata" :height 120)
(setq apropos-do-all t
      auto-save-default nil
      backup-directory-alist `(("." . ,(concat user-emacs-directory
      create-lockfiles nil
      inhibit-startup-message t
      mode-line-modes
      (mapcar (lambda (elem)
                (pcase elem
                  (`(:propertize (,_ minor-mode-alist . ,_) . ,_)
                   "")
                  (t elem)))
              mode-line-modes)
      mouse-yank-at-point t
      recentf-save-file (concat user-emacs-directory ".recentf")
      recentf-max-menu-items 40
      ring-bell-function 'ignore
      save-interprogram-paste-before-kill t
      save-place-file (concat user-emacs-directory "places")

      TeX-PDF-mode nil
      x-select-enable-clipboard t
      x-select-enable-primary t)
(setq-default save-place t
              word-wrap t
              cursor-type 'bar)
(blink-cursor-mode 1)
(fset 'yes-or-no-p 'y-or-n-p)
(global-display-line-numbers-mode 1)
(global-eldoc-mode -1)
(menu-bar-mode -1)
(when (fboundp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (fboundp 'scroll-bar-mode)
  (scroll-bar-mode -1))
(show-paren-mode 1)
(global-set-key (kbd "C-;") 'toggle-comment-on-line)
(global-set-key (kbd "C-a") 'beginning-of-line-or-indentation)
(global-set-key (kbd "C-c b") 'switch-to-previous-buffer)
(global-set-key (kbd "C-c c") 'list-colors-display)
(global-set-key (kbd "C-c l") 'toggle-truncate-lines)
(global-set-key (kbd "C-r") 'isearch-backward-regexp)
(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "C-x k") 'kill-buffer-and-window)
(global-set-key (kbd "C-z") nil)
(global-set-key (kbd "C-x C-b") 'ibuffer)
(global-set-key (kbd "C-c C-w") 'whack-whitespace)
(global-set-key (kbd "C-M-s") 'isearch-forward)
(global-set-key (kbd "C-M-r") 'isearch-backward)
(global-set-key (kbd "<M-return>") 'open-line)
(global-set-key (kbd "M-b") 'backward-word)
(global-set-key (kbd "M-B") 'backward-to-word)
(global-set-key (kbd "M-f") 'forward-word)
(global-set-key (kbd "M-F") 'forward-to-word)
(global-set-key (kbd "M-m") 'toggle-frame-maximized)
(global-set-key (kbd "M-p") 'backward-paragraph)
(global-set-key (kbd "M-n") 'forward-paragraph)

#+END_SRC
** ACTIVE All the Icons
I'm using =all-the-icons= to get unicode support for most images. I still see a few unicode strings in emails that can't be converted to images, though.
#+BEGIN_SRC emacs-lisp
(require-package 'all-the-icons)
(require 'all-the-icons)
#+END_SRC
** ACTIVE Company
I use =company= as my go-to completion engine. I have it enabled globally because I can't think of a time where I /don't/ want completion. I had had trouble with =company= taking a long time to list completions, it turned out =company-idle-delay= was the setting I needed for this. It took me too long to figure that out. Set it if you want to change how long you have to wait for =company= completions to appear.
#+BEGIN_SRC emacs-lisp
(require-package 'company)
(require 'company)
(setq company-idle-delay 0
      company-minimum-prefix-length 2
      company-selection-wrap-around nil
      company-tooltip-align-annotations t)
(add-hook 'after-init-hook 'global-company-mode)
#+END_SRC
** ACTIVE Flycheck
Almost every buffer uses =flycheck= either for code syntax or spelling via =flyspell=. I don't have any modes where I don't want =flycheck=, so I enabled them globally.
#+BEGIN_SRC emacs-lisp
(require-package 'flycheck)
(require 'flycheck)
(add-hook 'after-init-hook 'global-flycheck-mode)
#+END_SRC
** ACTIVE Flyspell
I recently discovered that Flyspell has a =prog-mode= version that only looks for spelling errors in strings, and I'm liking it so far.
#+BEGIN_SRC emacs-lisp
(require 'flyspell)
(define-key flyspell-mode-map (kbd "C-;") nil)
(define-key flyspell-mode-map (kbd "C-.") 'flyspell-auto-correct-previous-word)
(add-hook 'org-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC
** ACTIVE Ido
Ido provides great minibuffer completion.
#+BEGIN_SRC emacs-lisp
(require 'ido)
(setq ido-use-filename-at-point nil
      ido-auto-merge-work-directories-length -1
      ido-use-virtual-buffers t)
(ido-mode t)
#+END_SRC
** ACTIVE LaTeX Preview Pane
I like =latex-preview-pane= because it's an easy way to get side-by-side LaTeX editing and PDF previewing, as well as error highlighting. Dynamic inline rendering is often spotty as you add more packages, but the pane seems to work well so far.
#+BEGIN_SRC emacs-lisp
(require-package 'latex-preview-pane)
(add-hook 'TeX-mode-hook
          (lambda()
            (local-set-key (kbd "C-c r") 'latex-preview-pane-mode)))
#+END_SRC
** ACTIVE MHTML
MHTML is par for every other package I've used for HTML templates. I don't have any real configuration for it, just a bunch of snippets.
#+BEGIN_SRC 
(add-hook 'mhtml-mode-hook 'toggle-truncate-lines)
#+END_SRC
** ACTIVE Multiple Cursors
Multiple cursors was one thing I missed from Sublime Text, so =multiple-cursors= was a happy discovery.
#+BEGIN_SRC emacs-lisp
(require-package 'multiple-cursors)
(require 'multiple-cursors)
(global-set-key (kbd "C-c m") 'mc/edit-lines)
#+End_SRC
** ACTIVE Recentf
#+BEGIN_SRC emacs-lisp
(require 'recentf)
(recentf-mode 1)
#+END_SRC
** ACTIVE Ripgrep
I use =rg= for searching through files for text when a language-server can't do the job.
#+BEGIN_SRC emacs-lisp
(require-package 'rg)
#+END_SRC
** ACTIVE SanityInc Tomorrow Themes
For now, sanityinc is my go-to for themes. It took some work to get it to load properly on daemon startup, though. I created the =my-bypass-confirmation= function because sanityinc loads themes with a command instead of a variable. Consequently, you have to give the ok to load a sanityinc theme which causes problems in daemon mode since there's no one to give the ok. The other functions are keybindings. I have found =beginning-of-line-or-indentation= and =whack-whitespace= very useful, but I almost never use =switch-to-previous-buffer=.
#+BEGIN_SRC emacs-lisp
(require-package 'color-theme-sanityinc-tomorrow)
(defmacro my-with-advice (adlist &rest body)
  "Executes BODY with temporary advice in ADLIST."
  (declare (debug ((&rest (&rest form)) body))
           (indent 1))
  `(progn
     ,@(mapcar (lambda (adform)
                 (cons 'advice-add adform))
               adlist)
     (unwind-protect (progn ,@body)
       ,@(mapcar (lambda (adform)
                   `(advice-remove ,(car adform) ,(nth 2 adform)))
                 adlist))))
(defun my-bypass-confirmation (function &rest args)
  "Call FUNCTION with ARGS, bypassing all 'y-or-n-p' prompts."
  (my-with-advice
   ((#'y-or-n-p :override (lambda (prompt) t)))
   (apply function args)))
(my-bypass-confirmation 'color-theme-sanityinc-tomorrow-night)
#+END_SRC
** ACTIVE Smex
I always forget what =smex= does, it's a valuable addition to =ido= that gives precedence to most frequently used completions.
#+BEGIN_SRC emacs-lisp
(require-package 'smex)
(smex-initialize)
(setq smex-save-file (concat user-emacs-directory ".smex-items"))
(global-set-key (kbd "M-x") 'smex)
#+END_SRC
** ACTIVE Treemacs
I use =treemacs= mostly to get a visual on project structure. Its integration with =lsp-mode= is also nice for viewing project symbol information.
#+BEGIN_SRC emacs-lisp
(require-package 'treemacs)
(require 'treemacs)
(global-set-key (kbd "C-x D") 'treemacs)
(global-set-key (kbd "C-x p") 'treemacs-display-current-project-exclusively)
(define-key treemacs-mode-map (kbd "C-d") 'treemacs-remove-project-from-workspace)
(define-key treemacs-mode-map (kbd "M-f") 'treemacs-next-project)
(define-key treemacs-mode-map (kbd "M-p") 'treemacs-previous-project)
#+END_SRC
** ACTIVE Yasnippet
I am slowly using =yasnippet= more, I'm considering adding an integration with =company= for snippet completion, but part of me thinks that at that point I have a bigger problem.
#+BEGIN_SRC emacs-lisp
(require-package 'yasnippet)
(yas-global-mode 1)
(global-set-key (kbd "C-c x") 'yas-expand)
#+END_SRC
* ACTIVE Mu4e
One of the main drivers for me to use =mu4e= (or another Emacs package) for email management is to provide access to email in =org-mode=. This really shines when you need to make a =TODO= item from an email. You simply use a capture template, insert a link to the email, flesh out the =TODO= tasks, and save. If you leave and have to come back, there is no need to go to your inbox and find the email, everything is in your =TODO=.

If you don't want this functionality, simply set the state from =ACTIVE= to =DISABLED=. If you do want it, there are a few things to install to make Emacs work as a mail client. The first task is to Install =mu4e=, =isync=, =html2text= and =gpg2= via apt: =sudo apt install mu4e isync html2text gnupg2=.

Create a file whose contents is your mail password and encrypt via gpg2: =gpg2 -c .authinfo= 

Remove original files and place the encrypted ones in folders with names to match the references in =~/.config/emacs/mu4e/.mbsyncrc=.

Create a file whose contents is your mail password and encrypt via gpg2: =gpg2 -c .authinfo= 

Remove original files and place the encrypted ones in folders with names to match the references in =~/.config/emacs/mu4e/.mbsyncrc=.

With everything installed we need to perform an initial sync using =mbsync=. Before that, a mail directory must be create: =mkdir ~/Mail= 

Now, mail can be synced using the config file. First, create your mail directory at =~/Mail=. A different location will require configuration changes. Since the config is in an unconventional directory, it must be specified explicitly. First, navigate to =~/.config/emacs/mu4e= and run =mbsync -c .mbsyncrc -a= 

The last step is to index the messages with mu: =mu index --maildir="~/Mail=.

I've defined a couple of convenience functions. If an email just won't render as text, I have =mu4e-show-in-browser=. I'm holding onto hope for better webkit support so I'm keeping =mu4e-view-in-browser-webkit= around for the time being. I've never had occasion to use =search-for-sender=, but it seems like a basic function that any email client should have.

I have a lot of customization for =mu4e=. Admittedly, most of it was taken from other peoples' configuration I found online. An interesting aspect of =mu4e= is contexts, which can be associated with an email address. This provides separation between work and home, for example.
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e/")
(require 'mu4e)
(require 'smtpmail)
(defun mu4e-show-in-browser ()
  "Show an email in the default web browser."
  (interactive)
  (mu4e-action-view-in-browser (mu4e-action-view-in-browser (mu4e-message-at-point t))))
(defun mu4e-view-in-browser-webkit (msg)
  "View the email MSG in embedded browser."
  (let ((url (concat "file://" (mu4e~write-body-to-html msg))))
    (xwidget-webkit-browse-url url)))
(defun search-for-sender (msg)
  "Search for MSG messages sent by the sender of the message at point."
  (mu4e-headers-search
    (concat "from:" (cdar (mu4e-message-field msg :from)))))
(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))
(setq message-kill-buffer-on-exit t
      mu4e-attachment-dir "~/Downloads"
      mu4e-change-filenames-when-moving t
      mu4e-compose-context-policy 'always-ask
      mu4e-compose-dont-reply-to-self t
      mu4e-compose-in-new-frame t
      mu4e-compose-format-flowed t
      mu4e-compose-signature-auto-include nil
      mu4e-confirm-quit t
      mu4e-context-policy 'pick-first
      mu4e-contexts
      (list
       (make-mu4e-context
        :name "general"
        :enter-func (lambda () (mu4e-message "Entering general context"))
        :leave-func (lambda () (mu4e-message "Leaving general context"))
        :match-func (lambda (msg)
                      (when msg
                            (mu4e-message-contact-field-matches
                             msg '(:from :to :cc :bcc) "andrewwburch@gmail.com")))
        :vars '((user-mail-address . "andrewwburch@gmail.com")
                (user-full-name . "Andrew Burch")
                (mu4e-sent-folder . "/Sent")
                (mu4e-refile-folder . "/All")
                (mu4e-drafts-folder . "/Drafts")
                (mu4e-trash-folder . "/Trash")
                (mu4e-compose-signature . (concat "Cheers,\n Andrew"))
                (mu4e-compose-format-flowed . t)
                (smtpmail-queue-dir . "~/Mail/gmail/queue/cur")
                (message-send-mail-function . smtpmail-send-it)
                (smtpmail-smtp-user . "andrewwburch")
                (smtpmail-starttls-credentials . (("smtp.gmail.com" 587 nil nil)))
                (smtpmail-auth-credentials . (expand-file-name "~/.authinfo.gpg"))
                (smtpmail-default-smtp-server . "smtp.gmail.com")
                (smtpmail-smtp-server . "smtp.gmail.com")
                (smtpmail-smtp-service . 587)
                (smtpmail-debug-info . t)
                (smtpmail-debug-verbose . t))))
      mu4e-headers-auto-update t
      mu4e-headers-date-format "%H:%M %d-%m-%Y"
      ;; mu4e-html2text-command "html2text -utf8"
      ;; mu4e-html2text-command 'my-render-html-message
      mu4e-get-mail-command "mbsync -c ~/.config/emacs/mu4e/.mbsyncrc -a"
      mu4e-maildir (expand-file-name "~/Mail")
      mu4e-sent-messages-behavior 'delete
      mu4e-update-interval 180
      mu4e-view-html-plaintext-ratio-heuristic most-positive-fixnum
      mu4e-view-prefer-html nil
      mu4e-view-show-images t
      mu4e-view-show-addresses 't
      smtpmail-queue-mail nil)
(add-to-list 'mu4e-view-actions '("xsearch for sender" . search-for-sender) t)
(add-to-list 'mu4e-view-actions '("Webkit" . mu4e-view-in-browser-webkit) t)
(add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)
(add-hook 'mu4e-compose-mode-hook
          (defun compose-mail ()
            "Settings for mail composition."
            (use-hard-newlines -1)))
(add-hook 'mu4e-headers-mode-hook
          (defun mu4e-change-head()
            (interactive)
            (setq mu4e-headers-fields `((:date . 22)
                                        (:flags . 6)
                                        (:from . 22)
                                        (:thread-subject . ,(- (window-body-width) 70))
                                        (:size . 7)))))
(add-hook 'mu4e-view-mode-hook
          (lambda()
            (local-set-key (kbd "<RET>") 'mu4e-view-browse-url-from-binding)
            (local-set-key (kbd "<tab>") 'shr-next-link)
            (local-set-key (kbd "<backtab>") 'shr-previous-link)
            (toggle-truncate-lines)))
#+END_SRC
* Org 
** ACTIVE Built-in Config
For org, I wanted to use =C-o= as a leader key, so I remapped =open-line= to =M-return=. I also had a bit of time one winter visiting in-laws, so I decided to make a bunch of icons to customize the look of my =org-agenda=. For tasks and habits, I sync my phone with my files on my computer. The app I use is called Orgzly, which stores completion events in a =LOGBOOK= drawer. Luckily org-mode has an =org-log-into-drawer= setting to create the same functionality so my app and desktop work together seamlessly.

My keybindings for org are mostly unnecessary remappings to better integrate with my workflow. That, and more centralized access to =org= and =org-roam= commands I use frequently via the =C-o= leader-key remapping.

I only have one function, which is meant to change the status of a parent task to =DONE= when all child tasks are set to =DONE=. I forgot about it and haven't really used it. Need to make sure it works.
#+BEGIN_SRC emacs-lisp
(defun org-summary-todo (n-done n-not-done)
    "Switch entry to DONE when all subentries are done, to TODO otherwise."
    (let (org-log-done org-log-states)    ; turn off logging
      (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
(define-prefix-command 'ring-map)
(global-set-key (kbd "C-o") 'ring-map)
(setq org-capture-templates
        '(("t" "todo" entry (file+headline "~/org/tasks/Todo.org" "Tasks")
           "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n%a\n")
          ("d" "dream" entry (file "~/org/dreams/Dreams.org")
           "* %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n%?"))
        org-directory "~/org")
(with-eval-after-load "org"
    (org-load-modules-maybe t)
    (define-key org-mode-map (kbd "C-c i") 'org-insert-link)

    (define-key org-mode-map (kbd "<M-return>") nil)
    (define-key org-mode-map (kbd "<C-return>") 'org-insert-heading))

(global-set-key (kbd "C-o c") 'org-capture)

(add-hook 'mu4e-compose-mode-hook 'org-mu4e-compose-org-mode)
(add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
(add-hook 'org-mode-hook 'org-indent-mode)
(add-hook 'org-mode-hook 'toggle-truncate-lines)
#+END_SRC
** ACTIVE Org Habit
Org habit is useful for recurring todos. The main component to habits is that they be scheduled ideally using the =org-schedule= command (=C-c C-s=), and within that schedule date, before the closing angle bracket, set a reminder interval and an optional due date interval separated by a slash: =.+2d= or =.+2d/4d=.
#+BEGIN_SRC emacs-lisp
(require 'org-habit)
(setq org-modules '(org-habit))
#+END_SRC
** ACTIVE Org Journal
#+BEGIN_SRC emacs-lisp
(require-package 'org-journal)
(require 'org-agenda)
(require 'org-journal)
(setq org-journal-date-format "%A, %B %d %Y"
      org-journal-dir "~/org/journal/"
      org-journal-enable-agenda-integration t
      org-journal-file-format "%Y.org"
      org-journal-file-type "yearly"
      org-journal-skip-carryover-drawers t)
(add-to-list 'org-agenda-files org-journal-dir)
#+END_SRC
** ACTIVE Org Roam
Org Roam is great for managing information about things I'm learning about. In order for =org-roam= to work, it requires =sqlite3=, which is included in the install script at the beginning of the README. If you want to be able to display everything in a graph you need Graphviz: =sudo apt install graphviz=.
#+BEGIN_SRC emacs-lisp
(require-package 'org-roam)
(require-package 'org-roam-server)
(require 'org)
(require 'org-roam-protocol)
(setq org-roam-capture--file-name-default "%<%Y%m%d>"
      org-roam-completion-system 'ido
      org-roam-capture-templates
      '(("d" "default" plain (function org-roam--capture-get-point)
         "%?"
         :file-name "%<%Y%m%d>-${slug}"
         :head "#+title: ${title}\n"
         :unnarrowed t))
      org-roam-directory "~/org-roam"
      org-roam-graph-edge-extra-config '(
      ("color" . "green")
      ("fillcolor" . "green"))
      org-roam-graph-extra-config '(
      ("bgcolor" . "lightgray"))
      org-roam-graph-node-extra-config '(
      ("color" . "skyblue")
      ("fillcolor" . "skyblue")
      ("fontname" . "Arial")
      ("style" . "filled"))
      ;;org-roam-graph-viewer nil
      org-roam-server-host "127.0.0.1"
      org-roam-server-port 8000
      org-roam-server-authenticate nil
      org-roam-server-export-inline-images t
      org-roam-server-serve-files nil
      org-roam-server-served-file-extensions '("pdf")
      org-roam-server-network-poll t
      org-roam-server-network-arrows nil
      org-roam-server-network-label-truncate t
      org-roam-server-network-label-truncate-length 60
      org-roam-server-network-label-wrap-length 20)
(org-roam-server-mode)
(define-key org-mode-map (kbd "C-c i") 'org-roam-insert)
(global-set-key (kbd "C-o C-r c") 'org-roam-capture)
(add-hook 'after-init-hook 'org-roam-mode)
(global-set-key (kbd "C-o C-r f") 'org-roam-find-file)
(global-set-key (kbd "C-o C-r g") 'org-roam-graph)
(global-set-key (kbd "C-o C-r i") 'org-roam-insert)
#+END_SRC
** ACTIVE Ox-Hugo
Currently, I'm using =ox-hugo= to manage my personal website. Most of the custom configuration for that is in the site's org file as local variables so it doesn't show up here. That site is in a separate repo [[https://gitlab.com/AblatedSprocket/nothingissimple][here]].
#+BEGIN_SRC emacs-lisp
(require-package 'ox-hugo)
(require 'ox-hugo)
#+END_SRC
** ACTIVE Org Agenda
I'm not good about using it, but the intention here is to have =org-agenda= manage the tasks I set for myself every day. It works in conjunction with the Orgzly app for mobile. Orgzly logs task completions in a =LOGBOOK= drawer, so to make org-mode compatible, I added the =org-log-into-drawer= setting.
#+BEGIN_SRC emacs-lisp
(require 'org)
(setq org-agenda-breadcrumbs-separator " ‚ù± "
      org-agenda-category-icon-alist '(("Appointment" "~/.config/emacs/icons/bell.svg" nil nil :ascent center)
                                       ("Cleaning" "~/.config/emacs/icons/flower.svg" nil nil :ascent center)
                                       ("Contractor" "~/.config/emacs/icons/tools.svg" nil nil :ascent center)
                                       ("Exercise" "~/.config/emacs/icons/barbell.svg" nil nil :ascent center)
                                       ("Finance" "~/.config/emacs/icons/columns.svg" nil nil :ascent center)
                                       ("Journal" "~/.config/emacs/icons/journal.svg" nil nil :ascent center)
                                       ("Learning" "~/.config/emacs/icons/flask.svg" nil nil :ascent center)
                                       ("Life" "~/.config/emacs/icons/leaf.svg" nil nil :ascent center)
                                       ("Maintenance" "~/.config/emacs/icons/wrench.svg" nil nil :ascent center)
                                       ("Organizing" "~/.config/emacs/icons/folder.svg" nil nil :ascent center)
                                       ("Party" "~/.config/emacs/icons/beer.svg" nil nil :ascent center)
                                       ("Todo" "~/.config/emacs/icons/gears.svg" nil nil :ascent center))
      org-agenda-files '("~/org/tasks/Todo.org")
      org-log-into-drawer "LOGBOOK")
(add-to-list 'org-agenda-custom-commands
               '("x" "Testing tags for negating DONE" tags "-TODO=\"DONE\"" nil nil ))
#+END_SRC
* Prose
** ACTIVE Auctex
LaTeX support is provided by Auctex. In general I use Org for writing, but if I need something typeset, Auctex is what I use. I like having =C-c r= point to a run-like function, and generating a preview is about as close to "running" a LaTeX file as you can get in my opinion, so that's what I went with.
#+BEGIN_SRC emacs-lisp
(require-package 'auctex)
#+END_SRC
** ACTIVE Company-Auctex
#+BEGIN_SRC emacs-lisp
(require-package 'company-auctex)
#+END_SRC
** ACTIVE Olivetti
Some parts of a standard word processor I missed until I learned about Olivetti. I mostly wanted the document centered on the page with a fixed width. I'm still exploring its capabilities, but if more is desired, Olivetti might not be the way to go.

I like the idea of keeping code and more creative writing separate, so I wanted a font to enforce that separation.
I kind of fiddled around with different widths in =olivetti= mode to see what felt right for a typical document. I go back and forth on which file types to trigger Olivetti on. I've put in Markdown and org, but those don't feel right a lot of the time. I always go back to plain old =txt= files, though.
#+BEGIN_SRC emacs-lisp
(require-package 'olivetti)
(require 'olivetti)
(defun set-printing-font ()
  "Set font to Gentium."
  (face-remap-add-relative 'default '(:family "Gentium")))
(setq olivetti-body-width 84)
(add-to-list 'auto-mode-alist '("\\.txt\\'" . olivetti-mode))
(add-hook 'olivetti-mode-hook
         (lambda()
           (setq display-line-numbers nil)))
(add-hook 'olivetti-mode-hook 'set-printing-font)
(add-hook 'olivetti-mode-hook 'flyspell-mode)
#+END_SRC
* General Code Configuration
** ACTIVE HL-Todo
HL-Todo highlights to-do items in buffers where the mode is active. Previously, I used a package called =fic-mode=, which is supposed to only highlight to-dos in strings and comments but it didn't work as advertised.
#+BEGIN_SRC emacs-lisp
(require-package 'hl-todo)
(require 'hl-todo)
(add-hook 'prog-mode-hook 'hl-todo-mode)
#+END_SRC
** ACTIVE LSP
So far, I use Python and Rust in Emacs, both of which have good LSP options. Because of this, I have a section for general, LSP-oriented configuration and separate sections for each language that is supported by the =lsp-mode= umbrella. 
#+BEGIN_SRC emacs-lisp
(require-package 'lsp-mode)
(require 'lsp-mode)
;; Previously this required with-eval-after-load lsp
(setq lsp-modeline-diagnostics-scope :project
      lsp-signature-doc-lines 1)
(define-key lsp-mode-map (kbd "C-c a") 'lsp-execute-code-action)
(define-key lsp-mode-map (kbd "C-c d") 'lsp-describe-thing-at-point)
(define-key lsp-mode-map (kbd "C-c s") 'lsp-find-references)
(define-key lsp-mode-map (kbd "C-c e") 'lsp-rename)
(define-key lsp-mode-map (kbd "C-c S") 'lsp-treemacs-symbols)
#+END_SRC
** ACTIVE LSP-Treemacs
I haven't actually used =treemacs-magit= yet. It was a package I read about and was convinced I needed. I am only just starting to get comfortable with =magit= after spending many months using the CLI. I imagine I will have more to say about =treemacs-magit= soon.
I have found =lsp-treemacs= pretty useful. I like being able to see all of the symbols in a project, similar to the Object Explorer in Visual Studio.
#+BEGIN_SRC emacs-lisp
(require-package 'lsp-treemacs)
#+END_SRC
** ACTIVE Magit
I am not sure if =magit= should be in this section or a more general configuration section. I'm seeing more and more places outside of code where source control would be useful.
#+BEGIN_SRC emacs-lisp
(require-package 'magit)
#+END_SRC
** ACTIVE Treemacs-Magit
#+BEGIN_SRC emacs-lisp
(require-package 'treemacs-magit)
#+END_SRC
** ACTIVE Rainbow Delimiters
For me, =rainbow-delimiters= has saved me a lot of time tracking down parentheses and brackets in Rust and the little elisp I am willing to commit to.
#+BEGIN_SRC emacs-lisp
(require-package 'rainbow-delimiters)
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+END_SRC
** ACTIVE Programming
This is the configuration I have for general programming. For code, =toggle-comment-on-line= has been an invaluable function that I use all of the time as a keybinding. I have the various binaries that Emacs needs access to for programming languages (for linting, LSP connections, etc) installed at =~/.local/bin=, so I have those settings set up here.
#+BEGIN_SRC emacs-lisp
(defun toggle-comment-on-line ()
  "Comment or uncomment current line."
  (interactive)
  (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
(add-to-list 'exec-path "~/.local/bin")
(setenv "PATH" (concat "~/.local/bin:" (getenv "PATH")))
(define-key prog-mode-map (kbd "C-c h") 'hs-toggle-hiding)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
(add-hook 'prog-mode-hook 'hl-line-mode)
(add-hook 'prog-mode-hook 'hs-minor-mode)
(add-hook 'prog-mode-hook (lambda ()
                            (setq indent-tabs-mode nil)))
#+END_SRC
** ACTIVE Blacken
Currently, I use =blacken= for code formatting.
#+BEGIN_SRC emacs-lisp
(require-package 'blacken)
(require 'blacken)
(require 'python)
(define-key python-mode-map (kbd "C-c f") 'blacken-buffer)
#+END_SRC
** ACTIVE LSP-Pyls
The one thing I dislike about Python and pep8 in general is the "line too long" suggestions.
#+BEGIN_SRC emacs-lisp
(require 'lsp-pyls)
(setq lsp-pyls-plugins-pycodestyle-ignore '("E501"))
#+END_SRC
** ACTIVE Pyvenv
I use =pyvenv= to interface with my projects' virtual environments.
#+BEGIN_SRC emacs-lisp
(require-package 'pyvenv)
(setq pyvenv-default-virtual-env-name "venv")
(define-key python-mode-map (kbd "C-c r")
   (lambda()
     (interactive)
     (compile (concat "venv/bin/python3 " (buffer-name)))))
(add-hook 'python-mode-hook 'pyvenv-mode)
#+END_SRC
** ACTIVE Python
If you are not interested in Python development, you can set the state of the Python heading to =DISABLED= with no side-effects. If you are interested, this configuration uses Python 3. Currently my system is using Python 3.8. There is not much to my Python development scheme. On a fresh OS, you may need pip, which is included in the big install script under [[*Installation][Installation]]. To get started with Python development, install python language server and black: =pip3 install 'python-language-server[all]' black=. Python language server provides the backend for LSP-mode, and black is a nifty formatting tool to make code conform to pep8. Emacs uses Python development features via LSP-mode.

For the most part, the keybindings I like for Python development are covered by LSP, so the only thing here, really, are =electric-pair= completions. Even those are pretty universal and probably better suited for the general code settings section.
#+BEGIN_SRC emacs-lisp
(require 'python)
(define-key python-mode-map "'" 'electric-pair)
(define-key python-mode-map "\"" 'electric-pair)
(define-key python-mode-map "(" 'electric-pair)
(define-key python-mode-map "(" 'electric-pair)
(define-key python-mode-map "[" 'electric-pair)
(define-key python-mode-map "{" 'electric-pair)
(add-hook 'python-mode-hook 'lsp)
#+END_SRC
** ACTIVE Rust Flycheck
#+BEGIN_SRC emacs-lisp
(require 'flycheck)
(require 'flycheck-rust)
(require-package 'flycheck-rust)
(add-hook 'rust-mode-hook 'flycheck-rust-setup)
#+END_SRC
** ACTIVE Rust 
Development for Rust is pretty low-level at this point. If you're not interested in Rust development, you can change the state of the Rust heading to =DISABLED= with no side-effects. If you are interested in Rust, the first thing you should do is install [[https://www.rust-lang.org/tools/install][Rust]]. You'll want the source code for development: =rustup component add rust-src=. Rust-Analyzer is available on nightly now, so you /can/ run =rustup update nightly= and =rustup component add --toolchain nightly rust-analyzer-preview= to get it. The Rust-Analyzer version in nightly lags what's available, however, so if you want the most recent edition of Rust-Analyzer, download it from Github. At some point I'll add a section about developing Rust for embedded systems.

The only packages I've found helpful enough to warrant including are =rust-mode= and =flycheck-rust=. There's a =cargo-mode= as well, but I just bind the cargo shell commands to the =compile= command. That way I can also add whatever flags I want for the compiler. I wrote a function to ask for custom build arguments since I so frequently compile for both Desktop and my Raspberry Pis. Personally, I like using an updated version of Rust-Analyzer, so I just put the binary in my =~/.local/bin= directory and add it to Emacs' =PATH= and =exec-path=. The last thing is to tell =rust-mode= to activate when a =.rs= file is opened. The keybindings I use for Rust are mostly quality-of-life completions and Rust-specific versions of the generic code bindings I mentioned in [[*Code Settings][Code Settings]]. Rust is kind of interesting because the comipler provides a =check= command that compiles the code without statically linking anything. This provides error checking without the overhead of a full build. I'm contemplating using this as my default build command, but I compile for other targets so frequently that a separate command is fine for now. It is, however, non-intuitive to use =check= when every other mode uses a different command.
#+BEGIN_SRC emacs-lisp
(require-package 'rust-mode)
(require 'rust-mode)
(require 'lsp-mode)
(defun cargo-build (arg)
  "Build with input ARG."
  (interactive "MCargo Build arguments: ")
  (compile (concat "cargo build " arg)))
(setenv "PATH" (concat "~/.local/bin:" (getenv "PATH")))
(setq lsp-rust-analyzer-server-display-inlay-hints t
      lsp-rust-analyzer-server-command '("~/.local/bin/rust-analyzer")
      lsp-rust-server 'rust-analyzer)
(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
(add-to-list 'exec-path "~/.local/bin")
(define-key rust-mode-map "'" 'electric-pair)
(define-key rust-mode-map "\"" 'electric-pair)
(define-key rust-mode-map "(" 'electric-pair)
(define-key rust-mode-map "(" 'electric-pair)
(define-key rust-mode-map "[" 'electric-pair)
(define-key rust-mode-map "{" 'electric-pair)
(define-key rust-mode-map (kbd "C-c b") 'cargo-build)
(define-key rust-mode-map (kbd "C-c f") 'rust-format-buffer)
(define-key rust-mode-map (kbd "C-c r")
  (lambda ()
    (interactive)
    (compile "cargo run")))
(define-key rust-mode-map (kbd "C-c k")
  (lambda ()
    (interactive)
    (compile "cargo check")))
(define-key rust-mode-map (kbd "C-c t")
  (lambda ()
    (interactive)
    (compile "cargo test -- --nocapture")))
(define-key rust-mode-map (kbd "C-c C-f") nil)
(add-hook 'rust-mode-hook 'lsp)
#+END_SRC
* SQL Client Configuration
** ACTIVE Built-In SQL
My configuration also provides some customization of Emacs =SQL= mode. My workflow for SQL usually consists of two buffers: one of a SQL file and the other is the SQL interactive buffer. The SQL file is helpful because I can save and track my queries easily without thinking about it and the keeping the SQLi buffer separate is nice because I can disable font-lock so query results don't have silly distracting faces. The first function disables font-lock for =sql-interactive-mode= and the second sets up the =sql-interactive-mode= buffer automatically when =sql-mode= is enabled (either by opening a SQL buffer or manually activating =sql-mode=). Here, I've set up a list of connections I use frequently. I was surprised by how much of a quality-of-life improvement this was. I made a couple of keybindings for sending region and the whole buffer to the =sql-interactive-mode= buffer. I believe there are existing bindings for this, but I wanted something more in keeping with the rest of my keybinding setup. 
The only package used here so far is =sqlup-mode= which auto capitalizes SQL keywords to replicate what many SQL clients do.
#+BEGIN_SRC emacs-lisp
(require 'sql)
(defun my-sql-disable-font-lock (orig-fun &rest args)
  "Disable syntax highlighting for SQL output."
  (cl-letf (((symbol-function #'sql-product-font-lock) #'ignore))
    (apply orig-fun args)))
(defun my-sql-login-hook ()
  "Custom SQL log-in behaviors."
  (when (eq sql-product 'postgres)
    (let ((proc (get-buffer-process (current-buffer))))
      (comint-send-string proc "\\set ECHO queries\n"))))
(setq sql-connection-alist
      '(
        (home (sql-product 'postgres)
              (sql-port 5432)
              (sql-server "localhost")
              (sql-user "postgres")
              (sql-database "savetheglobe"))
        (savetheglobe_home (sql-product 'postgres)
                           (sql-port 5432)
                           (sql-server "localhost")
                           (sql-user "postgres")
                           (sql-database "savetheglobe"))
        (savetheglobe_heroku (sql-product 'postgres)
                             (sql-port 5432)
                             (sql-server "ec2-52-87-22-151.compute-1.amazonaws.com")
                             (sql-user "nrsgquqvfevzbu")
                             (sql-database "ddpfocn81le95m"))))

(define-key sql-mode-map (kbd "C-c s") 'sql-send-region)
(define-key sql-mode-map (kbd "C-c S") 'sql-send-buffer)
(advice-add 'sql-interactive-mode :around 'my-sql-disable-font-lock)
(add-hook 'sql-mode-hook 'sql-set-sqli-buffer)
(add-hook 'sql-mode-hook '(lambda ()
                            (setq truncate-lines t
                                  word-wrap nil)))
;; (add-hook 'sql-login-hook 'my-sql-login-hook)
#+END_SRC
** ACTIVE SQLUp
#+BEGIN_SRC emacs-lisp
(require-package 'sqlup-mode)
(require 'sql)
(add-hook 'sql-mode-hook 'sqlup-mode)
(add-hook 'sql-interactive-mode-hook 'sqlup-mode)
#+END_SRC


