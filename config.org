* Emacs Configuration
#+startup: overview

For my own sake, I've tabulated my Emacs dependencies and their purpose so I can remember what's going on:

| Package           | Function                                                                      |
|-------------------+-------------------------------------------------------------------------------|
| gnupg2            | I use this in my Mu4e config and Gnus Authinfo for managing logins for things |
| graphviz          | Provides neat visualization of org-roam trees                                 |
| isync             | Provides mbsync as Mu4e mail synchronization application                      |
| mu4e              | Mail client                                                                   |
| postgresql        | RDBMS (Used to SQL server, felt like I needed an alternative)                 |
| python3-pip       | Python package manager                                                        |
| python3-venv      | Python virtual environment system                                             |
| ripgrep           | grep alternative                                                              |
| sqlite3           | SQLite RDBMS                                                                  |

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
;;; config.el --- Summary
;;; Commentary:
;;; This file is generated by org-babel-tangle. For persistent changes, edit 'config.org' instead!
;;; Code:
#+END_SRC

Some packages have dependencies, and the script for all dependencies available to =pacman= using default repositories is provided here. Before installing, it is a good idea to update:

#+BEGIN_SRC sh :tangle yes :padline no
sudo pacman -Syu \
#+END_SRC

* Packages

All packages are installed up front to allow more flexibility with configuration organization.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(straight-use-package 'all-the-icons)
(straight-use-package 'auctex)
(straight-use-package 'cape)
(straight-use-package 'consult)
(straight-use-package 'consult-flycheck)
(straight-use-package 'corfu)
(straight-use-package 'emms)
(straight-use-package '(ablated-sprocket-themes-emacs :host github :repo "ablatedsprocket/ablated-sprocket-emacs-themes"))
(straight-use-package 'flycheck)
(straight-use-package 'flyspell-correct)
(straight-use-package 'gruvbox-theme)
(straight-use-package 'hl-todo)
(straight-use-package 'htmlize)
(straight-use-package 'ibuffer-vc)
(straight-use-package 'langtool)
(straight-use-package 'latex-preview-pane)
(straight-use-package 'magit)
(straight-use-package 'meow)
(straight-use-package 'mw-thesaurus)
(straight-use-package 'ob-restclient)
(straight-use-package 'orderless)
(straight-use-package 'org-contrib)
;;(straight-use-package 'org-roam)
(straight-use-package 'peep-dired)
(straight-use-package 'rainbow-delimiters)
(straight-use-package 'rainbow-mode)
(straight-use-package 'restclient)
(straight-use-package 'rg)
(straight-use-package 'simple-httpd)
;;(straight-use-package 'sqlup-mode)	
;;(straight-use-package 'treemacs-magit)
(straight-use-package 'vertico)
(straight-use-package 'yasnippet)
(straight-use-package '(ox-slimhtml :host github :repo "ablatedsprocket/ox-slimhtml"))
#+END_SRC

* Themes

I'm a big fan of Doom's themes. When using Nord themes from their own repository, I had a hard time getting them to work properly when running Emacs as a daemon. I don't have that issue using Nord from Doom's repository. Maybe Nord fixed it upstream, not sure.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(if (daemonp)
    (load-theme 'scenery t)
  (load-theme 'scenery t))
#+END_SRC

* General

This section contains all of the configuration related to built-in packages.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'flycheck)
(require 'remember)
(defun apply-post-frame-config ()
  (set-cursor-color "#ffff00")
  (set-face-attribute 'fixed-pitch nil :font "Roboto Mono 14")
  (set-face-attribute 'variable-pitch nil :font "Roboto 14")
  (set-face-attribute 'default nil :font "Roboto Mono 14"))
(defun autopair-insert (arg)
  (interactive "P")
  (let (pair)
    (cond
     ((assq last-command-event skeleton-pair-alist)
      (autopair-open arg))
     (t
	(autopair-close arg)))))
(defun autopair-open (arg)
  (interactive "P")
  (let ((pair (assq last-command-event
		    skeleton-pair-alist)))
    (cond
     ((and (not mark-active)
	   (eq (car pair) (car (last pair)))
	   (eq (car pair) (char-after)))
      (autopair-close arg))
     (t
      (skeleton-pair-insert-maybe arg)))))
(defun autopair-close (arg)
  (interactive "P")
  (cond
   (mark-active
    (let (pair open)
      (dolist (pair skeleton-pair-alist)
	(when (eq last-command-event (car (last pair)))
	  (setq open (car pair))))
      (setq last-command-event open)
      (skeleton-pair-insert-maybe arg)))
   ((looking-at
     (concat "[ \t\n]*"
	     (regexp-quote (string last-command-event))))
    (replace-match (string last-command-event))
    (indent-according-to-mode))
   (t
    (self-insert-command (prefix-numeric-value arg))
    (indent-according-to-mode))))
(defun custom-toggle-comment ()
  "Toggle comment on region if region is active else toggle comment on line."
  (interactive)
  (if (use-region-p)
      (comment-or-uncomment-region (region-beginning) (region-end))
    (toggle-comment-on-line)))
(defun dired-open-file ()
  "In dired, open the selected file on this line."
  (interactive)
  (let* ((file (dired-get-filename nil t)))
    (message "Opening %s..." file)
    (call-process "xdg-open" nil 0 nil file)))
(defun highlight-todo-bracket ()
  (font-lock-add-keywords nil '(("\\[TODO:.*\\]" 0 'font-lock-warning-face prepend))))
(defun highlight-todo-semicolon ()
  (font-lock-add-keywords nil '(("^;;+\s*?\\(TODO:.*$\\)" 1 'font-lock-warning-face prepend))))
(defun highlight-todo-slash ()
  (font-lock-add-keywords nil '(("^//+\s*?\\(TODO:.*$\\)" 1 'font-lock-warning-face))))
(defun toggle-comment-on-line ()
  "Comment or uncomment current line."
  (interactive)
  (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
(defun whack-whitespace (arg)
  "Deletes all white space from point to the next word. With prefix ARG delete across newlines as well. The only danger in this is that you don't have to actually be at the end of a word to make it work. It skips over to the next whitespace and then whacks it all to the next word."
  (interactive "P")
  (let ((regexp (if arg "[ \t\n]+" "[ \t]+")))
    (re-search-forward regexp nil t)
    (replace-match "" nil nil)))
(setq auto-save-default nil ;; don't autosave
      backup-directory-alist `(("." . ,(concat user-emacs-directory "backups")))
      completion-category-defaults nil
      completion-styles '(orderless) ;; Provide fuzzy search matching.
      completion-category-overrides '((file (styles basic partial-completion)))
      create-lockfiles nil
      custom-file (expand-file-name "custom.el") ;; Keep custom outside of init, gets annoying in source control.
      dired-dwim-target t
      dired-listing-switches "-al --group-directories-first"
      inhibit-startup-message t
      initial-major-mode 'org-mode ;; Major mode for scratch buffer
      initial-scratch-message "* Scratch\n\nThis is an org-mode buffer for text that is not saved.\n\n"
      mode-line-modes
      (mapcar (lambda (elem)
		(pcase elem
		  (`(:propertize (,_ minor-mode-alist . ,_) . ,_)
		   "")
		  (t elem)))
	      mode-line-modes)
      mouse-yank-at-point t
      read-file-name-completion-ignore-case t
      recentf-save-file (concat user-emacs-directory ".recentf")
      recentf-max-menu-items 40
      ring-bell-function 'ignore
      save-interprogram-paste-before-kill t
      save-place-file (concat user-emacs-directory "places")
      sentence-end "[\\.\\?\\!] +" ;; By default, Emacs recognizes a period (or question mark, exclamation mark, etc.) followed by two spaces as the end of a sentence. I only ever use one space.
      skeleton-pair t
      skeleton-pair-alist '((?\( _ ?\))
			    (?\[  _ ?\])
			    (?{  _ ?})
			    (?\" _ ?\"))
      TeX-PDF-mode nil
      x-select-enable-clipboard t
      x-select-enable-primary t)
(setq-default cursor-type 'bar
	      display-line-numbers-width-start t
	      save-place t
	      truncate-lines nil
	      word-wrap t)
(blink-cursor-mode 1)
(column-number-mode 1) ;; Show column number in modeline
(add-hook 'emacs-lisp-mode-hook 'highlight-todo-semicolon)
(add-hook 'text-mode-hook 'highlight-todo-bracket)
(flycheck-add-mode 'proselint 'text-mode)
(fset 'yes-or-no-p 'y-or-n-p) ;; Use 'y' or 'n' instead of 'yes' or 'no' in relevant prompts.
(global-eldoc-mode -1) ;; Disable showing function arguments in echo area.
(global-display-line-numbers-mode)
(menu-bar-mode -1) ;; Disable menu bar UI.
(tool-bar-mode -1) ;; Disable tool bar UI.
(savehist-mode) ;; Enable saving history for more relevant minibuffer completions.
(scroll-bar-mode -1) ;; Disable scroll bars.
(show-paren-mode 1) ;; Highlight matching parens.
(define-key minibuffer-inactive-mode-map (kbd ")") nil) ;; Disable auto-pair of parentheses in minu-buffer.
(if (daemonp)
    (add-hook 'server-after-make-frame-hook 'apply-post-frame-config)
  (apply-post-frame-config))
#+END_SRC

** General Dependencies

When you use fonts installed from the Linux repositories, they don't have the metadata that allows Emacs to recognize italic and bold versions of a font, so they don't render. Instead, download the bold, italic, regular, and bolditalic versions of Alegreya and Hack and place the =.ttf= files in =/usr/local/share/fonts/=

* All the Icons

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'all-the-icons)
#+END_SRC

* Cape

Cape provides completion-at-point functions that aren't available by default in Corfu. Below are the functions I use and why:

| Function     | Reason                                       |
|--------------+----------------------------------------------|
| cape-dabbrev | Completions based on words in current buffer |

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'cape)
(add-to-list 'completion-at-point-functions #'cape-dabbrev)
#+END_SRC

* Consult

My preferred completion engine.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(setq consult-project-root-function (lambda () (cdr (project-current))))
#+END_SRC

* Consult-Flycheck


#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'consult-flycheck)
#+END_SRC

* Corfu

It took a while, but I finally got Corfu where I wanted it once I realized I needed to install Cape to get the same buffer completions provided by Company. I moved to Corfu as part of my desire to move to packages that leverage built-in Emacs utilities. Also, Corfu supports orderless completions which are amazing in-buffer.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'corfu)
(require 'orderless)
(setq corfu-quit-no-match t
      corfu-cycle t
      corfu-auto t
      tab-indent-always 'complete)
(corfu-global-mode 1)
#+END_SRC

* Discord

Let's make Emacs show up in Discord, mostly because we can. Enable with =M-x elcord-mode=. If you're not on Discord and the mode's active, you'll keep getting notifications that Elcord is trying to connect. I'm not always on Discord, so this gets annoying.

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require 'elcord)
#+END_SRC

** Discord Dependencies
 
First install Bitlbee:

#+BEGIN_SRC sh :padline no
sudo apt install bitlbee-dev
#+END_SRC

Then, Bitlbee-Discord needs to be installed from [[https://github.com/sm00th/bitlbee-discord][source]].
* Ejira

I'm working on a couple of programming projects outside of work, one with another person. He wanted to use Jira, and I noticed that there are a couple of Jira integrations for Emacs, Org-Jira and Ejira. I chose Ejira because it takes advantage of Jira's REST API, as opposed to Org-Jira which is SOAP-based. It's much easier for me to debug JSON payloads as opposed to XML. Currently, the Ejira files are included with my config for two reasons: one is that Ejira is not on MELPA yet, and the second is that there's some deal-breaking functionality missing from the maintained branch, mostly mentioning users.

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require-package 'cl-lib)
(require-package 'dash)
(require-package 'dash-functional)
(require-package 'language-detection)
(require-package 'ox-jira)
(require-package 's)
(require 'ejira)
(setq jiralib2-url "https://jasonandandybuildsomething.atlassian.net"
      jiralib2-auth 'token
      jiralib2-user-login-name "andrewwburch@gmail.com"
      jiralib2-token (auth-source-pick-first-password
		      :host "jasonandandybuildsomething.atlassian.net"
		      :user "andrewwburch@gmail.com")
      ejira-org-directory "~/.jira"
      ejira-projects '("SB")
      ejira-priorities-alist '(("Highest" . ?A)
			       ("High"    . ?B)
			       ("Medium"  . ?C)
			       ("Low"     . ?D)
			       ("Lowest"  . ?E))
      ejira-todo-states-alist '(("To Do"  . 1)
				("Doing" . 2)
				("Test"  . 3)
				("Done"  . 4))
      ejira-org-todo-keywords-alist '(("SB" . ("TODO"
					       "DOING"
					       "TEST"
					       "DONE")))
      org-id-track-globally t)
#+END_SRC

* EMMS

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require 'emms)
(require 'emms-setup)
(emms-all)
(setq emms-info-functions '(emms-info-exiftool)
      emms-player-list '(emms-player-vlc)
      emms-source-file-default-directory (expand-file-name "~/Music")
      emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find)
#+END_SRC

** EMMS Dependencies

#+BEGIN_SRC sh :tangle no :padline no
sudo apt install exiftool vlc
#+END_SRC

* ERC

Obligatory change =irc.freenode.net= to =irc.libera.chat=.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'erc)
(setq erc-default-server "irc.libera.chat")
#+END_SRC

* Flycheck

I want to see all of the errors!

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'flycheck)
(add-hook 'after-init-hook 'global-flycheck-mode)
#+END_SRC

* Flyspell

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'flyspell)
(setq ispell-program-name "/usr/bin/aspell")
(defun flyspell-goto-previous-error (arg)
  "Go to arg previous spelling error."
  (interactive "p")
  (while (not (= 0 arg))
    (let ((pos (point))
	  (min (point-min)))
      (if (and (eq (current-buffer) flyspell-old-buffer-error)
	       (eq pos flyspell-old-pos-error))
	  (progn
	    (if (= flyspell-old-pos-error min)
		;; goto beginning of buffer
		(progn
		  (message "Restarting from end of buffer")
		  (goto-char (point-max)))
	      (backward-word 1))
	    (setq pos (point))))
      ;; seek the next error
      (while (and (> pos min)
		  (let ((ovs (overlays-at pos))
			(r '()))
		    (while (and (not r) (consp ovs))
		      (if (flyspell-overlay-p (car ovs))
			  (setq r t)
			(setq ovs (cdr ovs))))
		    (not r)))
	(backward-word 1)
	(setq pos (point)))
      ;; save the current location for next invocation
      (setq arg (1- arg))
      (setq flyspell-old-pos-error pos)
      (setq flyspell-old-buffer-error (current-buffer))
      (goto-char pos)
      (if (= pos min)
	  (progn
	    (message "No more miss-spelled word!")
	    (setq arg 0))
	(forward-word)))))
(add-hook 'org-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC

** Flyspell dependencies

Flyspell requires =aspell=:

#+BEGIN_SRC sh :tangle yes :padline no
aspell aspell-en \
#+END_SRC
* Flyspell-Correct

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'flyspell-correct)
#+END_SRC

* GPG-Agent

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(defun pinentry-emacs (desc prompt ok error)
  (let ((str (read-passwd (concat (replace-regexp-in-string "%22" "\"" (replace-regexp-in-string "%0A" "\n" desc)) prompt ": "))))
    str))
#+END_SRC

* Htmlize

Mostly for testing Org files exported to HTML.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'htmlize)
#+END_SRC

* IBuffer-VC

IBuffer-VC organizes the list of open buffers by project, as defined by =project.el=. Pretty handy.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'ibuffer-vc)
(add-hook 'ibuffer-mode-hook 'ibuffer-vc-set-filter-groups-by-vc-root)
#+END_SRC

* Langtool

Langtool provides grammar checking. Useful? Debatable!

#+BEGIN_SRC emacs-lisp :tangle no :padline no
;; (setq langtool-http-server-host "localhost"
;; langtool-http-server-port 8081)
(setq langtool-language-tool-jar "~/.local/lib/LanguageTool-5.5/languagetool-commandline.jar")
(require 'langtool)
#+END_SRC

** Langtool Dependencies

A JRE must be installed. Download the files from Langtool's [[https://dev.languagetool.org/http-server.html][website]].

* LSP

So far, I use Python and Rust in Emacs, both of which have good LSP options. Because of this, I have a section for general, LSP-oriented configuration and separate sections for each language that is supported by the LSP mode umbrella. 

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require 'lsp-mode)
(setq lsp-modeline-diagnostics-scope :project
      lsp-signature-doc-lines 1)
;; TODO: Remap these keys to evil-leader variants at some point.
(define-key lsp-mode-map (kbd "C-c `") 'lsp-restart-workspace)
(define-key lsp-mode-map (kbd "C-c a") 'lsp-execute-code-action)
(define-key lsp-mode-map (kbd "C-c d") 'lsp-describe-thing-at-point)
(define-key lsp-mode-map (kbd "C-c s") 'rg)
(define-key lsp-mode-map (kbd "C-c e") 'lsp-rename)
(define-key lsp-mode-map (kbd "C-c S") 'lsp-treemacs-symbols)
#+END_SRC

* LSP-Treemacs

I have found LSP-Treemacs pretty useful. I like being able to see all of the symbols in a project, similar to the Object Explorer in Visual Studio.

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require 'lsp-treemacs)
#+END_SRC

* Magit

Magit or git command line. Those are the only options.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'magit)
#+END_SRC

* Meow

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(defun meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
  (meow-motion-overwrite-define-key
   '("n" . meow-next)
   '("p" . meow-prev)
   '("<escape>" . ignore))
  (meow-leader-define-key
   ;; SPC j/k will run the original command in MOTION state.
   '("n" . "H-n")
   '("p" . "H-p")
   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))
  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '(";" . custom-toggle-comment)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-next)
   '("o" . meow-block)
   '("O" . meow-to-block)
   '("p" . meow-prev)
   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . isearch-forward)
   '("t" . meow-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   '("w" . meow-next-word)
   '("W" . meow-next-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-yank)
   '("Y" . meow-sync-grab)
   '("z" . zap-up-to-char)
   '("Z" . zap-to-char)
   '("'" . repeat)
   '("<escape>" . ignore)))
(require 'meow)
(meow-setup)
(meow-global-mode 1)
#+END_SRC

* Mu4e

One of the main drivers for me to use Mu4e (or another Emacs package) for email management is to provide access to email in Org mode. This really shines when you need to make a =TODO= item from an email. You simply use a capture template, insert a link to the email, flesh out the =TODO= tasks, and save. If you leave and have to come back, there is no need to go to your inbox and find the email, everything is in your =TODO=.

If you don't want this functionality, simply set the state from =ACTIVE= to =DISABLED=. If you do want it, there are a few things to install to make Emacs work as a mail client. Be sure to install the [[* Mu4e Dependencies][dependencies]] before moving ahead.

With everything installed we need to perform an initial sync using the =mbsync= command. Before that, a mail directory must be created: =mkdir ~/Mail= 

My =.mbsyncrc= is set up to use Gnus Authinfo, so we need to set that up as well. It's not too bad, simply create a file named =~/.authinfo= and add this line:

#+BEGIN_SRC sh :tangle no
machine smtp.gmail.com login USERNAME password PASSWORD port 587
#+END_SRC

Now, encrypt the file with the following command:

#+BEGIN_SRC sh :tangle no
gpg2 --symmetric .authinfo
#+END_SRC

Emacs has support for reading these encrypted files built-in. Just open the file in a buffer. Should you need to decrypt, though, just enter the following:

#+BEGIN_SRC sh :tangle no
gpg2 --decrypt .authinfo.gpg
#+END_SRC

I have Mu4e hooked up to my gmail account so that's how the example is laid out. Of course, you will need to substitute your username and password for the capitalized words, but other than that you should be good.

As an aside, Gnus Authinfo can be used in a variety of ways in Emacs: many packages support it. I recommend looking into it for any packages interfacing with a service you log into like Slack or Gitlab.

Now, mail can be synced using the config file. First, create your mail directory at =~/Mail=. A different location will require configuration changes. Since the config is in an unconventional directory, it must be specified explicitly. First, navigate to =~/.config/emacs/mu4e= and run =mbsync -c .mbsyncrc -a= 

The last step is to index the messages with mu:

#+BEGIN_SRC sh :tangle no
mu init --maildir=~/mail=
mu index
#+END_SRC

I've defined a convenience function called =search-for-sender= which I've never had occasion to use, but it seems like a basic function that any email client should have.

I have a lot of customization for Mu4e. Admittedly, most of it was taken from other peoples' configuration I found online. An interesting aspect of Mu4e contexts, which can be associated with an email address. This provides separation between work and home, for example.

*NOTE:* Mu4e has [[* Mu4e Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e/")
(add-to-list 'load-path "/usr/share/emacs/site-lisp/ox-rss/")
(require 'mu4e)
(require 'smtpmail)
(require 'org-mu4e)
(defun search-for-sender (msg)
  "Search for MSG messages sent by the sender of the message at point."
  (mu4e-headers-search
   (concat "from:" (cdar (mu4e-message-field msg :from)))))
(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))
(setq message-kill-buffer-on-exit t
      mu4e-attachment-dir "~/downloads"
      mu4e-change-filenames-when-moving t ;; This is supposed to be better for mbsync
      mu4e-compose-context-policy 'always-ask ;; Ask which email address you want to send from
      mu4e-compose-dont-reply-to-self t
      mu4e-compose-in-new-frame t
      mu4e-compose-format-flowed t ;; Part of sending messages with long lines, I don't want Mu4e inserting linebreaks randomly.
      mu4e-compose-signature-auto-include nil
      mu4e-confirm-quit t
      mu4e-context-policy 'pick-first ;; Pick first available context, change if I eventually add more email addresses.
      mu4e-contexts
      (list
       (make-mu4e-context
	:name "general"
	:enter-func (lambda () (mu4e-message "Entering general context"))
	:leave-func (lambda () (mu4e-message "Leaving general context"))
	:match-func (lambda (msg)
		      (when msg
			(mu4e-message-contact-field-matches
			 msg '(:from :to :cc :bcc) "andrewwburch@gmail.com")))
	:vars '((user-mail-address . "andrewwburch@gmail.com")
		(user-full-name . "Andrew Burch")
		(mu4e-sent-folder . "/sent")
		(mu4e-refile-folder . "/all")
		(mu4e-drafts-folder . "/drafts")
		(mu4e-trash-folder . "/trash")
		(mu4e-compose-signature . (concat "Cheers,\n Andrew"))
		(mu4e-compose-format-flowed . t)
		(smtpmail-queue-dir . "~/mail/gmail/queue/cur")
		(message-send-mail-function . smtpmail-send-it)
		(smtpmail-auth-credentials . (expand-file-name "~/.authinfo.gpg"))
		(smtpmail-debug-info . t)
		(smtpmail-default-smtp-server . "smtp.gmail.com")
		(smtpmail-local-domain . "gmail.com")
		(smtpmail-smtp-user . "andrewwburch")
		(smtpmail-smtp-server . "smtp.gmail.com")
		(smtpmail-smtp-service . 587)
		(smtpmail-starttls-credentials . (("smtp.gmail.com" 587 nil nil)))
		(smtpmail-debug-verbose . t))))
      mu4e-headers-auto-update t
      mu4e-headers-date-format "%H:%M %d-%m-%Y"
      mu4e-get-mail-command "mbsync -a"
      mu4e-maildir (expand-file-name "~/mail")
      mu4e-sent-messages-behavior 'delete ;; Gmail puts messages in Sent so Mu4e doesn't have to.
      mu4e-update-interval 300
      mu4e-view-html-plaintext-ratio-heuristic most-positive-fixnum ;; Always prefer plaintext over HTML.
      mu4e-view-prefer-html nil ;; More dissuasion from using HTML.
      mu4e-view-show-images t
      mu4e-view-show-addresses t
      smtpmail-queue-mail nil)
(add-to-list 'mu4e-view-actions '("xsearch for sender" . search-for-sender) t)
(add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)
(add-hook 'message-mode-hook (lambda () ;; Don't let Mu4e add newlines.
			       (use-hard-newlines -1)))
(add-hook 'mu4e-headers-mode-hook
	  (defun mu4e-change-head()
	    (interactive)
	    (setq mu4e-headers-fields `((:date . 22)
					(:flags . 6)
					(:from . 22)
					(:thread-subject . ,(- (window-body-width) 70))
					(:size . 7)))))
(add-hook 'mu4e-headers-mode-hook
	  (lambda ()
	    (setq display-line-numbers nil)))
(add-hook 'mu4e-view-mode-hook
	  (lambda()
	    (local-set-key (kbd "<RET>") 'mu4e-view-browse-url-from-binding)
	    (local-set-key (kbd "<tab>") 'shr-next-link)
	    (local-set-key (kbd "<backtab>") 'shr-previous-link)
	    ))
#+END_SRC

** Mu4e Dependencies

Mu4e itself needs to be installed from AUR. Its other dependencies can be installed with =pacman=:
#+BEGIN_SRC sh :tangle yes :padline no
isync html2text gnupg \
#+END_SRC 

* OB-Restclient

If it were up to me, I would never use Postman again. Incorporating literate programming into test suites is amazing, especially when you can mix Restclient with your programming langauge of choice. Of course, this isn't viable in a setting where multiple people are involved in a project.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'restclient)
(org-babel-do-load-languages 'org-babel-load-languages '((restclient .t)))
#+END_SRC

* Orderless

Orderless provides a nice completion function option that I was missing from Helm.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'orderless)
#+END_SRC

* Org

My Org config is getting kind of big.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'org)
(require 'org-protocol)
(defun generate-post ()
  (setq post-title (read-string "Title: "))
  (setq post-file-name (replace-regexp-in-string ":" "" (replace-regexp-in-string " " "-" (downcase post-title))))
  (expand-file-name (format "%s.org" post-file-name) "~/nothingissimple/org/posts"))
(defun generate-reference (title url body))
(defun org-export-latex-remove-labels (s backend info)
  (when (org-export-derived-backend-p org-export-current-backend 'latex)
    (replace-regexp-in-string "\\\\label{sec:org[a-z0-9]+}\n" "" s)))
(defun org-toggle-emphasis-markers ()
  "Toggle hiding/showing of org emphasis markers."
  (interactive)
  (if org-hide-emphasis-markers
      (set-variable 'org-hide-emphasis-markers nil)
    (set-variable 'org-hide-emphasis-markers t))
  (org-mode-restart))
(defun org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-log-states)    ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
(define-prefix-command 'ring-map)

(add-to-list 'font-lock-extra-managed-props 'invisible)
(set-face-attribute 'org-block nil :inherit 'fixed-pitch)
(set-face-attribute 'org-block-begin-line nil :inherit 'fixed-pitch)
(set-face-attribute 'org-block-end-line nil :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil :inherit 'fixed-pitch)
(set-face-attribute 'org-done nil :inherit '(org-headline-done fixed-pitch))
(set-face-attribute 'org-drawer nil :inherit 'fixed-pitch)
(set-face-attribute 'org-level-1 nil :height 2.0 :inherit 'default)
(set-face-attribute 'org-level-2 nil :height 1.75 :inherit 'default)
(set-face-attribute 'org-level-3 nil :height 1.5 :inherit 'default)
(set-face-attribute 'org-level-4 nil :height 1.25 :inherit 'default)
(set-face-attribute 'org-level-5 nil :height 1.1 :inherit 'default)
(set-face-attribute 'org-tag nil :inherit 'fixed-pitch)
(set-face-attribute 'org-property-value nil :inherit 'fixed-pitch)
(set-face-attribute 'org-special-keyword nil :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
(set-face-attribute 'org-todo nil :inherit 'fixed-pitch)
(set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)

(setq org-adapt-indentation nil
      org-capture-templates
      '(("e" "event" plain (function (lambda ()
				       (let ((path (read-file-name "Select file:")))
					 (find-file path)
					 (goto-char 0)
					 (if (search-forward "* Reference" nil t)
					     (progn
					       (org-end-of-subtree)
					       (newline))
					   (progn
					     (goto-char (point-max))
					     (newline)
					     (insert "* Reference")
					     (newline))
					   ))))
	 "\n** %^{Title}\nSCHEDULED: %(org-insert-timestamp (org-read-date nil t \"+1y\"))\n:PROPERTIES:\n:REF: %l\n:STYLE: habit\n:END:\n\n%(unless (string= (string-trim \"%i\") \"\")(format \"#+begin_quote\n%s\n#+end_quote\" \"%i\"))\n")
	("j" "journal" plain (file+datetree "~/org/journal.org")
	 "")
	("l" "link" entry (file+headline "~/org/tasks/Todo.org" "Tasks")
	 "* %a\n")
	("p" "post" plain (file generate-post)
	 "%(format \"#+title: %s\n#+date:\n#+filetags:\n#+slug: %s\n#+category: draft\n#+options: toc:nil num:nil\n#+description:\n\n\" post-title post-file-name)")
	("r" "recipe" entry (file+headline "~/org/recipes.org" "Recipes")
	 "%(format \"* %s\nSCHEDULED: %s\n\n|Quantity|Unit|Ingredient|Notes|\n|----%?\n\n\" (read-string \"Recipe name:\") (org-insert-timestamp (org-read-date nil t \"+1y\")))")
	("s" "skill" plain (function (lambda ()
				       (let ((path (read-file-name "Select file:")))
					 (find-file path)
					 (goto-char 0)
					 (if (search-forward "* Reference" nil t)
					     (progn
					       (org-end-of-subtree)
					       (newline))
					   (progn
					     (goto-char (point-max))
					     (newline)
					     (insert "* Reference")
					     (newline))))))
	 "\n** %^{Title}\n:PROPERTIES:\n:REF: %l\n:STYLE: habit\n:END:\n\n%(unless (string= (string-trim \"%i\") \"\")(format \"#+begin_quote\n%s\n#+end_quote\" \"%i\"))\n")
	("t" "todo" entry (file+headline "~/org/tasks/Todo.org" "Tasks")
	 "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n:PROPERTIES:\n:CATEGORY: Todo\n:END:\n"))
      org-edit-src-content-indentation 0
      org-directory "~/org"
      org-export-allow-bind-keywords t
      org-hide-emphasis-markers t
      org-hide-leading-stars t
      org-highest-priority ?A
      org-log-into-drawer "logbook"
      org-lowest-priority ?E)
(org-load-modules-maybe t)
(org-reload) ;; Noticed interactive org-export wasn't working properly unless calling this.
(define-key org-mode-map (kbd "<M-return>") nil)
(define-key org-mode-map (kbd "(") 'autopair-insert)
(define-key org-mode-map (kbd ")") 'autopair-insert)
(define-key org-mode-map (kbd "[") 'autopair-insert)
(define-key org-mode-map (kbd "]") 'autopair-insert)
(define-key org-mode-map (kbd "{") 'autopair-insert)
(define-key org-mode-map (kbd "}") 'autopair-insert)
(define-key org-mode-map (kbd "\"") 'autopair-insert)
(add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
(add-hook 'org-mode-hook (lambda ()
			   (electric-indent-local-mode -1)
			   (variable-pitch-mode)
			   (setq truncate-lines nil)))
(font-lock-add-keywords 'org-mode '(("^\\*+ " (0 '(face nil invisible t)))))
;; (setq org-export-filter-final-output-functions '(org-export-latex-remove-labels))
#+END_SRC
  
** Org Dependencies

To export to LaTeX, =texlive= is required:

#+BEGIN_SRC sh :tangle yes :padline no
texlive-most \
#+END_SRC
* Org-Roam

I'm still trying to figure out how to integrate Org-Roam into my workflow. It seems like it could be so helpful!

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(setq org-roam-v2-ack t)
(require 'org)
(require 'org-roam)
(require 'org-roam-protocol)
(setq org-roam-capture--file-name-default "%<%Y%m%d>"
      org-roam-capture-templates '(("d" "default" plain "%?"
				    :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
						       "#+title: ${title}\n")
				    :unnarrowed t))
      org-roam-completion-system 'ido
      org-roam-graph-edge-extra-config '(
					 ("color" . "green")
					 ("fillcolor" . "green"))
      org-roam-graph-extra-config '(
				    ("bgcolor" . "lightgray"))
      org-roam-graph-node-extra-config '(
					 ("color" . "skyblue")
					 ("fillcolor" . "skyblue")
					 ("fontname" . "Arial")
					 ("style" . "filled")))
(setq org-roam-directory "/home/andy/nothingissimple")
(org-roam-setup)
#+END_SRC

** Org-Roam Dependencies

Org-Roam manages nodes in a SQLite database, so that needs to be installed:

#+BEGIN_SRC sh :tangle no :padline no
sudo pacman -S sqlite3
#+END_SRC

Additionally, Org-Roam has nifty protocol support to enable external applications to send information to Emacs. Org has this support as well, but I wasn't able to get it working properly. Org-Roam seems to have gotten this down-pat because it worked straight away and was simpler to set up than Org based on the information I found. First, I created an application for other applications to use to send data to Emacs:

#+BEGIN_SRC :tangle no
[Desktop Entry]
Name=Org-Protocol
Exec=emacsclient %u
Icon=emacs-icon
Type=Application
Terminal=false
Categories=System;
MimeType=x-scheme-handler/org-protocol;
#+END_SRC

Now, other applications just need to be told to use this application. In a browser, for example, creating a bookmarklet lets me send information to Emacs using Roam-Ref:

#+BEGIN_SRC javascript :tangle no
javascript:location.href='org-protocol://roam-ref?template=f&ref='+encodeURIComponent(location.href)+'&title='+encodeURIComponent(document.title)+'&body='+encodeURIComponent(window.getSelection())
#+END_SRC

* Peep-Dired

Peep-Dired provides file previews.

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require 'evil-collection)
(evil-collection-define-key 'normal 'dired-mode-map
"V" 'peep-dired)
#+END_SRC
#+END_SRC

* Ox-SlimHTML

I mostly use a derived Ox-Slimhtml backend to generate my website, but this configuration also comes in handy for one-off documents.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'ox-slimhtml)
(defun ab/org-html-table (table contents info)
  "Transcodes a TABLE from Org to HTML.
	CONTENTS is the contents of the table.
	INFO is a plist used as a communication channel."
  (let ((caption (car (car (car (org-element-property :caption table))))))
    (concat "<table>\n"
	    (when caption
	      (format "<caption>%s</caption>\n" caption))
	    contents
	    "</tbody>\n</table>")))

(defun ab/org-html-table-row (table-row contents info)
  "Transcodes a TABLE-ROW from Org to HTML.
	CONTENTS is the contents of the row.
	INFO is a plist used as a communication channel."
  (if contents
      (concat (when (eq 1 (org-export-table-row-group table-row info))
		"<thead>\n")
	      "<tr>\n"
	      contents
	      "</tr>"
	      (when (eq 1 (org-export-table-row-group table-row info))
		"</thead>\n<tbody>\n"))))

(defun ab/export-as-html
    (&optional async subtreep visible-only body-only ext-plist)
  (interactive)
  (org-export-to-buffer 'trimhtml "*Org TRIMHTML Export*"
    async subtreep visible-only body-only ext-plist
    (lambda () (set-auto-mode t))))

(defun ab/export-to-html (&optional async subtreep visible-only body-only ext-plist)
  (interactive)
  (let* ((extension (concat "." (or (plist-get ext-plist :html-extension)
				    org-html-extension
				    "html")))
	 (file (org-export-output-file-name extension subtreep))
	 (org-export-coding-system org-html-coding-system))
    (org-export-to-file 'trimhtml file
      async subtreep visible-only body-only ext-plist ())))

(defun ab/org-html-table-cell (table-cell contents info)
  "Transcodes a TABLE-CELL from Org to HTML.
	CONTENTS is the contents of the cell.
	INFO is a plist used as a communication channel."
  (if (eq 1 (org-export-table-row-group (org-element-property :parent table-cell) info))
      (concat "<th>" contents "</th>")
    (concat "<td>" contents "</td>\n")))

(org-export-define-derived-backend 'trimhtml
    'slimhtml
  :menu-entry '(?a "trimhtml" 
		   ((?H "As trimhtml buffer" ab/export-as-html)
		    (?h "As trimhtml file" ab/export-to-html)))
  :translate-alist
  '((template . ox-slimhtml-template)
    (link . ox-slimhtml-link)
    (code . ox-slimhtml-verbatim)
    (headline . ox-slimhtml-headline)
    (table . ab/org-html-table)
    (table-cell . ab/org-html-table-cell)
    (table-row . ab/org-html-table-row))
  :options-alist
  '((:page-type "PAGE-TYPE" nil nil nil)
    (:html-use-infojs nil nil nil)
    (:description nil nil nil)
    (:category nil nil nil)))
#+END_SRC
  
* Rainbow Delimiters

For me, Rainbow Delimiters has saved a lot of time tracking down parentheses and brackets in Rust and what Elisp I am willing to commit to.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'rainbow-delimiters)
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

* Restclient

I'm hoping to use Restclient as a stand-in for Postman. I found an integration with Org-Babel that has been great to use. For me, Org-Babel is a must for Restclient.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'restclient)
#+END_SRC

* Ripgrep

I'm all about Rust implementations of things.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'rg)
#+END_SRC

** Ripgrep Dependencies

#+BEGIN_SRC sh :tangle yes :padline no
ripgrep \
#+END_SRC

* Rust

I only have a few programming languages I use regularly, Rust is one of them.

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require 'rust-mode)
(require 'lsp-mode)
(defun cargo-build (arg)
  "Build with input ARG."
  (interactive "MCargo Build arguments: ")
  (compile (concat "cargo build " arg)))
(add-to-list 'exec-path "~/.cargo/bin")
(setenv "PATH" (concat "~/.cargo/bin:" (getenv "PATH")))
(setq lsp-rust-analyzer-server-display-inlay-hints t
      lsp-rust-analyzer-server-command '("~/.local/bin/rust-analyzer")
      lsp-rust-server 'rust-analyzer)
(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
(define-key rust-mode-map (kbd "C-c b") 'cargo-build)
(define-key rust-mode-map (kbd "C-c f") 'rust-format-buffer)
(define-key rust-mode-map (kbd "C-c r")
  (lambda ()
    (interactive)
    (compile "cargo run")))
(define-key rust-mode-map (kbd "C-c k")
  (lambda ()
    (interactive)
    (compile "cargo check")))
(define-key rust-mode-map (kbd "C-c t")
  (lambda ()
    (interactive)
    (compile "cargo test -- --nocapture")))
(define-key rust-mode-map (kbd "C-c C-f") nil)
(add-hook 'rust-mode-hook 'lsp)
(add-hook 'rust-mode-hook 'highlight-todo)
#+END_SRC

** Rust Dependencies

To use Rust, it must first be [[https://www.rust-lang.org/tools/install][installed]]. Once that's done, install Rust-Analyzer by cloning the repository:

#+BEGIN_SRC sh :tangle no
git clone https://github.com/rust-analyzer/rust-analyzer.git
cd rust-analyzer
cargo xtask install --server
#+END_SRC

The =rust-analyzer= binary should now be visible under =~/.cargo/bin/=. Ensure Emacs knows about the path by adding the proper paths to the =add-to-list= and =setenv= configuration items in [[* Rust][Rust]] config.

To enable various IDE features, =rust-src= is required:

#+BEGIN_SRC sh :tangle no
rustup component add rust-src
#+END_SRC

* Rust Flycheck

Rust Flycheck provides syntax highlighting.

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require 'flycheck)
(require 'flycheck-rust)
(add-hook 'rust-mode-hook 'flycheck-rust-setup)
#+END_SRC

* SimpleHTTPd

I use Simple-HTTPd to host my website locally for debugging.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'simple-httpd)
(when (file-exists-p "~/nothingissimple/site")
   (setq httpd-root "~/nothingissimple/site"))
#+END_SRC

* SQL

My configuration also provides some customization of Emacs' SQL mode. My workflow for SQL usually consists of two buffers: one of a SQL file and the other is the SQL interactive buffer. The SQL file is helpful because I can save and track my queries easily without thinking about it and the keeping the SQLi buffer separate is nice because I can disable font-lock so query results don't have silly distracting faces. The first function disables font-lock for SQL Interactive mode and the second sets up the SQL Interactive-mode buffer automatically when SQL mode is enabled (either by opening a SQL buffer or manually activating SQL mode). Here, I've set up a list of connections I use frequently. I was surprised by how much of a quality-of-life improvement this was. I made a couple of keybindings for sending region and the whole buffer to the SQL Interactive mode buffer. I believe there are existing bindings for this, but I wanted something more in keeping with the rest of my keybinding setup. 

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require 'sql)
(defun my-sql-disable-font-lock (orig-fun &rest args)
  "Disable syntax highlighting for SQL output."
  (cl-letf (((symbol-function #'sql-product-font-lock) #'ignore))
    (apply orig-fun args)))
(defun my-sql-login-hook ()
  "Custom SQL log-in behaviors."
  (when (eq sql-product 'postgres)
    (let ((proc (get-buffer-process (current-buffer))))
      (comint-send-string proc "\\set ECHO queries\n"))))
(setq sql-connection-alist
      '(
	(home (sql-product 'postgres)
	      (sql-port 5432)
	      (sql-server "localhost")
	      (sql-user "postgres")
	      (sql-database "savetheglobe"))
	(savetheglobe_home (sql-product 'postgres)
			   (sql-port 5432)
			   (sql-server "localhost")
			   (sql-user "postgres")
			   (sql-database "savetheglobe"))
	(savetheglobe_heroku (sql-product 'postgres)
			     (sql-port 5432)
			     (sql-server "ec2-52-87-22-151.compute-1.amazonaws.com")
			     (sql-user "nrsgquqvfevzbu")
			     (sql-database "ddpfocn81le95m"))))

(define-key sql-mode-map (kbd "C-c r") 'sql-send-region)
(define-key sql-mode-map (kbd "C-c R") 'sql-send-buffer)
(advice-add 'sql-interactive-mode :around 'my-sql-disable-font-lock)
(add-hook 'sql-mode-hook 'sql-set-sqli-buffer)
(add-hook 'sql-mode-hook '(lambda ()
			    (setq truncate-lines t
				  word-wrap nil)))
;; (add-hook 'sql-login-hook 'my-sql-login-hook)
#+END_SRC

* SQLUp

SQLUp up-cases SQL keywords. I liked this in SSMS and enjoy having it in Emacs as well.

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require 'sql)
(add-hook 'sql-mode-hook 'sqlup-mode)
(add-hook 'sql-interactive-mode-hook 'sqlup-mode)
#+END_SRC

* Treemacs-Magit

I haven't had the opportunity to use this extensively yet.

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require 'treemacs-magit)
#+END_SRC
  
* Vertico

My preferred search utility. With Emacs 28, there's =fido-vertical-mode= built-in, but it doesn't support orderless filtering so I'm still using Vertico!

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(require 'vertico)
(vertico-mode)
#+END_SRC

* Vterm

I've been tinkering in the command line and documenting things in Emacs lately, so I've been using ~shell~ to make it easier to get command line output into documents. It works well enough, but I've wanted to try ~vterm~ to see what difference it makes. It's supposed to be a lot faster for commands with a lot of output, but I feel like I notice a difference even with simple commands. It also has better support for things like ~fish~ and themes.

*NOTE:* Vterm has [[* Vterm Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :tangle no :padline no
(require 'vterm)
(setq vterm-timer-delay 0.01)
#+END_SRC

** Vterm Dependencies

#+BEGIN_SRC sh :tangle no :padline no
sudo apt install cmake libtool-bin
#+END_SRC

* YASnippet

I am slowly using YASnippet more, I'm considering adding an integration with Company for snippet completion, but part of me thinks that at that point I have a bigger problem.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(yas-global-mode 1)
#+END_SRC

* Wrapping Up

Nothing to see here, just finishing touches on the config file.

#+BEGIN_SRC emacs-lisp :tangle yes :padline no
(provide 'config)
;;; config.el ends here
#+END_SRC

# Local Variables:
# after-save-hook: org-babel-tangle
# End:
