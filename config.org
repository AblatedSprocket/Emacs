# -*- mode: org; coding: utf-8; -*-
#+TODO: DISABLED | ACTIVE
#+STARTUP: indent

* Emacs Config

Everything in my Emacs configuration can be found here. I have broken it down into workflows, and each workflow is broken down into its comprising packages. Note that marking a heading as =ACTIVE= or =DISABLED= has no effect on its subheadings.

** ACTIVE General Configuration

These are the general purpose functions I've found or made over my time with Emacs. I have found =beginning-of-line-or-indentation= and =whack-whitespace= very useful as keybindings, but I almost never use =switch-to-previous-buffer=. I actually haven't used Apropos much, but after investigating it while writing this, I've discovered it is a very useful tool for discovering! It functions similarly to the =C-h= keybindings, but it's a bit more accessible in my opinion. The other big thing I want to point out is I disabled minor modes showing up in the modeline using the =mode-line-modes= setting. To use the Inconsolata font, you may have to install it first.

*NOTE:* General configuration has [[* General Configuration Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
  (defun beginning-of-line-or-indentation ()
    "Move to beginning of line or indentation."
    (interactive)
    (if (bolp)
        (back-to-indentation)
      (beginning-of-line)))
  (defun switch-to-previous-buffer()
    "Switch to previously open buffer.
  Repeated invocations toggle between the two most recently open buffers."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))
  (defun custom-toggle-comment ()
    "Toggle comment on region if region is active else toggle comment on line."
    (interactive)
    (if (use-region-p)
        (comment-or-uncomment-region (region-beginning) (region-end))
      (toggle-comment-on-line)))
  (defun whack-whitespace (arg)
      "Deletes all white space from point to the next word. With prefix ARG delete across newlines as well. The only danger in this is that you don't have to actually be at the end of a word to make it work. It skips over to the next whitespace and then whacks it all to the next word."
        (interactive "P")
        (let ((regexp (if arg "[ \t\n]+" "[ \t]+")))
          (re-search-forward regexp nil t)
          (replace-match "" nil nil)))
  (set-cursor-color "#ffff00")
  ;; (set-face-attribute 'default nil :font "Inconsolata" :height 120)
  (set-face-attribute 'default nil :font "Hack" :height 100)
  (setq apropos-do-all t
        auto-save-default nil
        backup-directory-alist `(("." . ,(concat user-emacs-directory "backups")))
        create-lockfiles nil
        inhibit-startup-message t
        mode-line-modes
        (mapcar (lambda (elem)
                  (pcase elem
                    (`(:propertize (,_ minor-mode-alist . ,_) . ,_)
                     "")
                    (t elem)))
                mode-line-modes)
        mouse-yank-at-point t
        recentf-save-file (concat user-emacs-directory ".recentf")
        recentf-max-menu-items 40
        ring-bell-function 'ignore
        save-interprogram-paste-before-kill t
        save-place-file (concat user-emacs-directory "places")

        TeX-PDF-mode nil
        x-select-enable-clipboard t
        x-select-enable-primary t)
  (setq-default save-place t
                word-wrap t
                cursor-type 'bar)
  (blink-cursor-mode 1)
  (column-number-mode 1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (global-display-line-numbers-mode 1)
  (global-eldoc-mode -1)
  (menu-bar-mode -1)
  (when (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
  (show-paren-mode 1)
  (global-set-key (kbd "M-;") 'custom-toggle-comment)
  (global-set-key (kbd "C-a") 'beginning-of-line-or-indentation)
  (global-set-key (kbd "C-c b") 'switch-to-previous-buffer)
  (global-set-key (kbd "C-c c") 'list-colors-display)
  (global-set-key (kbd "C-c l") 'toggle-truncate-lines)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-x k") 'kill-buffer-and-window)
  (global-set-key (kbd "C-z") nil)
  (global-set-key (kbd "C-c C-w") 'whack-whitespace)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "C-M-s") 'isearch-forward)
  (global-set-key (kbd "C-M-r") 'isearch-backward)
  (global-set-key (kbd "<M-return>") 'open-line)
  (global-set-key (kbd "M-b") 'backward-to-word)
  (global-set-key (kbd "M-B") 'backward-word)
  (global-set-key (kbd "M-f") 'forward-word)
  (global-set-key (kbd "M-F") 'forward-to-word)
  (global-set-key (kbd "M-m") 'toggle-frame-maximized)
  (global-set-key (kbd "M-p") 'backward-paragraph)
  (global-set-key (kbd "M-n") 'forward-paragraph)
#+END_SRC

*** General Configuration Dependencies

#+BEGIN_SRC shell
sudo apt install fonts-inconsolata fonts-hack
#+END_SRC

*** ACTIVE All the Icons

I'm using All the Icons to get unicode support for most images. I still see a few unicode strings in emails that can't be converted to images, though.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'all-the-icons)
(require 'all-the-icons)
#+END_SRC

*** ACTIVE Company

I use Company as my go-to completion engine. I have it enabled globally because I can't think of a time where I /don't/ want completion. I had had trouble with Company taking a long time to list completions, it turned out =company-idle-delay= was the setting I needed for this. It took me too long to figure that out. Set it if you want to change how long you have to wait for Company completions to appear.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'company)
(require 'company)
(setq company-idle-delay 0
      company-minimum-prefix-length 2
      company-selection-wrap-around nil
      company-tooltip-align-annotations t)
(add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

*** ACTIVE Electric-Pair
I miss having auto-completions for certain pairs. Every mode is a little different

#+BEGIN_SRC emacs-lisp :padline no
(defun electric-pair ()
  "Insert pair without spaces."
  (interactive)
  (let (parens-require-spaces) (insert-pair)))
#+END_SRC

*** ACTIVE Flycheck

Almost every buffer uses Flycheck either for code syntax or spelling via Flyspell. I don't fi have any modes where I don't want Flycheck, so I enabled them globally.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'flycheck)
(require 'flycheck)
(add-hook 'after-init-hook 'global-flycheck-mode)
#+END_SRC

*** ACTIVE Flyspell

I recently discovered that Flyspell has a Prog Mode version that only looks for spelling errors in strings, and I'm liking it so far.

#+BEGIN_SRC emacs-lisp :padline no
(defun flyspell-goto-previous-error (arg)
  "Go to arg previous spelling error."
  (interactive "p")
  (while (not (= 0 arg))
    (let ((pos (point))
          (min (point-min)))
      (if (and (eq (current-buffer) flyspell-old-buffer-error)
               (eq pos flyspell-old-pos-error))
          (progn
            (if (= flyspell-old-pos-error min)
                ;; goto beginning of buffer
                (progn
                  (message "Restarting from end of buffer")
                  (goto-char (point-max)))
              (backward-word 1))
            (setq pos (point))))
      ;; seek the next error
      (while (and (> pos min)
                  (let ((ovs (overlays-at pos))
                        (r '()))
                    (while (and (not r) (consp ovs))
                      (if (flyspell-overlay-p (car ovs))
                          (setq r t)
                        (setq ovs (cdr ovs))))
                    (not r)))
        (backward-word 1)
        (setq pos (point)))
      ;; save the current location for next invocation
      (setq arg (1- arg))
      (setq flyspell-old-pos-error pos)
      (setq flyspell-old-buffer-error (current-buffer))
      (goto-char pos)
      (if (= pos min)
          (progn
            (message "No more miss-spelled word!")
            (setq arg 0))
        (forward-word)))))
(require 'flyspell)
(define-key flyspell-mode-map (kbd "C-;") nil)
(define-key flyspell-mode-map (kbd "C-<") 'flyspell-goto-previous-error)
(define-key flyspell-mode-map (kbd "C-,") 'flyspell-auto-correct-previous-word)
(global-set-key (kbd "C->") 'forward-paragraph)
(add-hook 'org-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC

*** ACTIVE Ido

Ido provides great minibuffer completion.

#+BEGIN_SRC emacs-lisp :padline no
(require 'ido)
(setq ido-use-filename-at-point nil
      ido-auto-merge-work-directories-length -1
      ido-use-virtual-buffers t)
(ido-mode t)
#+END_SRC

*** ACTIVE Multiple Cursors

Multiple cursors was one thing I missed from Sublime Text, so Multiple-Cursors was a happy discovery.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'multiple-cursors)
(require 'multiple-cursors)
(global-set-key (kbd "C-c m") 'mc/edit-lines)
#+End_SRC

*** ACTIVE Recentf

#+BEGIN_SRC emacs-lisp :padline no
(require 'recentf)
(recentf-mode 1)
#+END_SRC

*** ACTIVE Ripgrep

I use Ripgrep for searching through files for text when a language-server can't do the job.

*NOTE:* Ripgrep has [[Ripgrep Dependencies][dependencies]]

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'rg)
#+END_SRC

**** Ripgrep Dependencies

#+BEGIN_SRC shell
sudo apt install ripgrep
#+END_SRC

*** DISABLED SanityInc Tomorrow Themes

For now, sanityinc is my go-to for themes. I'm a big fan of their night and day themes.

#+BEGIN_SRC emacs-lisp :padline no
(add-hook 'after-init-hook (lambda ()
  (load-theme 'sanityinc-tomorrow-night t)))
#+END_SRC

*** ACTIVE Nord Theme

I really like the Nord theme, but it's kind of hard to use with daemon mode. Luckily, I'm not the only one to run into this issue and there are workarounds, however the workarounds are a little unwieldy. The only grievance I have with Nord is that source blocks don't have any distinguishing background faces, so I set the =backgrond= property on the =org-block= face to =nord1= and the =background= property for =org-block-begin-line= and =org-block-end-line= faces to =nord2=. Hopefully, I'll figure out how to make those changes from my config here, but for now, they're in the Nord package I downloaded from MELPA. One caveat to this configuration is that the =:extend= property is only valid in Emacs 27+, so my configuration is getting increasingly unfriendly toward Emacs 26-.

#+BEGIN_SRC emacs-lisp
  (require-package 'nord-theme)
  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)  
                  (with-selected-frame frame (load-theme 'nord t))
                  (dolist (face '(org-block
                                    org-block-begin-line
                                    org-block-end-line
                                    org-level-1))
                                    (set-face-attribute face nil :extend t))))
    (load-theme 'nord t)
    (with-eval-after-load 'org
      (dolist (face '(org-block
                      org-block-begin-line
                      org-block-end-line
                      org-level-1))
        (set-face-attribute face nil :extend t))))
#+END_SRC

*** ACTIVE Smex

I always forget what Smex does, it's a valuable addition to Ido that gives precedence to most frequently used completions.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'smex)
(smex-initialize)
(setq smex-save-file (concat user-emacs-directory ".smex-items"))
(global-set-key (kbd "M-x") 'smex)
#+END_SRC

*** ACTIVE Treemacs

I use Treemacs mostly to get a visual on project structure. Its integration with LSP mode is also nice for viewing project symbol information.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'treemacs)
(require 'treemacs)
(global-set-key (kbd "C-x D") 'treemacs)
(global-set-key (kbd "C-x p") 'treemacs-display-current-project-exclusively)
(define-key treemacs-mode-map (kbd "C-d") 'treemacs-remove-project-from-workspace)
(define-key treemacs-mode-map (kbd "M-f") 'treemacs-next-project)
(define-key treemacs-mode-map (kbd "M-p") 'treemacs-previous-project)
#+END_SRC

*** ACTIVE Yasnippet

I am slowly using YASnippet more, I'm considering adding an integration with Company for snippet completion, but part of me thinks that at that point I have a bigger problem.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'yasnippet)
(yas-global-mode 1)
(global-set-key (kbd "C-c x") 'yas-expand)
#+END_SRC

** ACTIVE Mu4e

One of the main drivers for me to use Mu4e (or another Emacs package) for email management is to provide access to email in Org mode. This really shines when you need to make a =TODO= item from an email. You simply use a capture template, insert a link to the email, flesh out the =TODO= tasks, and save. If you leave and have to come back, there is no need to go to your inbox and find the email, everything is in your =TODO=.

If you don't want this functionality, simply set the state from =ACTIVE= to =DISABLED=. If you do want it, there are a few things to install to make Emacs work as a mail client. Be sure to install the [[* Mu4e Dependencies][dependencies]] before moving ahead.

With everything installed we need to perform an initial sync using the =mbsync= command. Before that, a mail directory must be created: =mkdir ~/Mail= 

My =.mbsyncrc= is set up to use Gnus Authinfo, so we need to set that up as well. It's not too bad, simply create a file named =~/.authinfo= and add this line:

#+BEGIN_SRC  :padline no
machine smtp.gmail.com login USERNAME password PASSWORD port 587
#+END_SRC

Now, encrypt the file with the following command:

#+BEGIN_SRC  :padline no
gpg2 --symmetric .authinfo
#+END_SRC

I have Mu4e hooked up to my gmail account so that's how the example is laid out. Of course, you will need to substitute your username and password for the capitalized words, but other than that you should be good.

As an aside, Gnus Authinfo can be used in a variety of ways in Emacs: many packages support it. I recommend looking into it for any packages interfacing with a service you log into like Slack or Gitlab.

Now, mail can be synced using the config file. First, create your mail directory at =~/Mail=. A different location will require configuration changes. Since the config is in an unconventional directory, it must be specified explicitly. First, navigate to =~/.config/emacs/mu4e= and run =mbsync -c .mbsyncrc -a= 

The last step is to index the messages with mu: =mu index --maildir=~/Mail=.

I've defined a convenience function called =search-for-sender= which I've never had occasion to use, but it seems like a basic function that any email client should have.

I have a lot of customization for Mu4e. Admittedly, most of it was taken from other peoples' configuration I found online. An interesting aspect of Mu4e contexts, which can be associated with an email address. This provides separation between work and home, for example.

*NOTE:* Mu4e has [[* Mu4e Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e/")
(require 'mu4e)
(require 'smtpmail)
(require 'org-mu4e)
(defun search-for-sender (msg)
  "Search for MSG messages sent by the sender of the message at point."
  (mu4e-headers-search
    (concat "from:" (cdar (mu4e-message-field msg :from)))))
(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))
(setq message-kill-buffer-on-exit t
      mu4e-attachment-dir "~/Downloads"
      mu4e-change-filenames-when-moving t
      mu4e-compose-context-policy 'always-ask
      mu4e-compose-dont-reply-to-self t
      mu4e-compose-in-new-frame t
      mu4e-compose-format-flowed t
      mu4e-compose-signature-auto-include nil
      mu4e-confirm-quit t
      mu4e-context-policy 'pick-first
      mu4e-contexts
      (list
       (make-mu4e-context
        :name "general"
        :enter-func (lambda () (mu4e-message "Entering general context"))
        :leave-func (lambda () (mu4e-message "Leaving general context"))
        :match-func (lambda (msg)
                      (when msg
                            (mu4e-message-contact-field-matches
                             msg '(:from :to :cc :bcc) "andrewwburch@gmail.com")))
        :vars '((user-mail-address . "andrewwburch@gmail.com")
                (user-full-name . "Andrew Burch")
                (mu4e-sent-folder . "/Sent")
                (mu4e-refile-folder . "/All")
                (mu4e-drafts-folder . "/Drafts")
                (mu4e-trash-folder . "/Trash")
                (mu4e-compose-signature . (concat "Cheers,\n Andrew"))
                (mu4e-compose-format-flowed . t)
                (smtpmail-queue-dir . "~/Mail/gmail/queue/cur")
                (message-send-mail-function . smtpmail-send-it)
                (smtpmail-smtp-user . "andrewwburch")
                (smtpmail-starttls-credentials . (("smtp.gmail.com" 587 nil nil)))
                (smtpmail-auth-credentials . (expand-file-name "~/.authinfo.gpg"))
                (smtpmail-default-smtp-server . "smtp.gmail.com")
                (smtpmail-smtp-server . "smtp.gmail.com")
                (smtpmail-smtp-service . 587)
                (smtpmail-debug-info . t)
                (smtpmail-debug-verbose . t))))
      mu4e-headers-auto-update t
      mu4e-headers-date-format "%H:%M %d-%m-%Y"
      ;; mu4e-html2text-command "html2text -utf8"
      ;; mu4e-html2text-command 'my-render-html-message
      mu4e-get-mail-command "mbsync -c ~/.config/emacs/mu4e/.mbsyncrc -a"
      mu4e-maildir (expand-file-name "~/Mail")
      mu4e-sent-messages-behavior 'delete
      mu4e-update-interval 180
      mu4e-view-html-plaintext-ratio-heuristic most-positive-fixnum
      mu4e-view-prefer-html nil
      mu4e-view-show-images t
      mu4e-view-show-addresses 't
      smtpmail-queue-mail nil)
(add-to-list 'mu4e-view-actions '("xsearch for sender" . search-for-sender) t)
(add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)
(add-hook 'message-mode-hook (lambda ()
          (use-hard-newlines -1)))
(add-hook 'mu4e-headers-mode-hook
          (defun mu4e-change-head()
            (interactive)
            (setq mu4e-headers-fields `((:date . 22)
                                        (:flags . 6)
                                        (:from . 22)
                                        (:thread-subject . ,(- (window-body-width) 70))
                                        (:size . 7)))))
(add-hook 'mu4e-view-mode-hook
          (lambda()
            (local-set-key (kbd "<RET>") 'mu4e-view-browse-url-from-binding)
            (local-set-key (kbd "<tab>") 'shr-next-link)
            (local-set-key (kbd "<backtab>") 'shr-previous-link)
            (setq truncate-lines t)))
#+END_SRC

*** Mu4e Dependencies

#+BEGIN_SRC shell
sudo apt install mu4e isync html2text gnupg2
#+END_SRC 

** ACTIVE Org

For org, I wanted to use =C-o= as a leader key, so I remapped =open-line= to =M-return=. I also had a bit of time one winter visiting in-laws, so I decided to make a bunch of icons to customize the look of my Org-Agenda. For tasks and habits, I sync my phone with my files on my computer. The app I use is called Orgzly, which stores completion events in a LOGBOOK= drawer. Luckily org-mode has an =org-log-into-drawer= setting to create the same functionality so my app and desktop work together seamlessly.

My keybindings for org are mostly unnecessary remappings to better integrate with my workflow.

I only have one function, which is meant to change the status of a parent task to =DONE= when all child tasks are set to =DONE=. I forgot about it and haven't really used it. Need to make sure it works.

#+BEGIN_SRC emacs-lisp :padline no
(require 'org)
(defun org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-log-states)    ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
(define-prefix-command 'ring-map)
(global-set-key (kbd "C-o") 'ring-map)
(setq org-capture-templates
      '(("t" "todo" entry (file+headline "~/org/tasks/Todo.org" "Tasks")
           "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n:PROPERTIES:\n:CATEGORY: Todo\n:END:\n")
          ("l" "link" entry (file+headline "~/org/tasks/Todo.org" "Tasks")
           "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n:PROPERTIES:\n:CATEGORY: Todo\n:Item: %a\n:END:\n"))
        org-directory "~/org"
        org-highest-priority ?A
      org-lowest-priority ?E)
(org-load-modules-maybe t)
(define-key org-mode-map (kbd "C-c i") 'org-insert-link)
(define-key org-mode-map (kbd "C-c o") 'org-open-at-point)
(define-key org-mode-map (kbd "C-c C-w") nil)
(define-key org-mode-map (kbd "<M-return>") nil)
(define-key org-mode-map (kbd "<C-return>") 'org-insert-heading)
(global-set-key (kbd "C-o c") 'org-capture)
(add-hook 'mu4e-compose-mode-hook 'org-mu4e-compose-org-mode)
(add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
(add-hook 'org-mode-hook (lambda ()
                           (org-indent-mode)
                           (setq truncate-lines t)))
#+END_SRC

*** ACTIVE Org-Agenda

I'm not good about using it, but the intention here is to have Org-Agenda manage the tasks I set for myself every day. It works in conjunction with the Orgzly app for mobile. Orgzly logs task completions in a =LOGBOOK= drawer, so to make org-mode compatible, I added the =org-log-into-drawer= setting.

#+BEGIN_SRC emacs-lisp :padline no
(require 'org)
(require 'org-agenda)
(setq org-agenda-breadcrumbs-separator " ‚ù± "
      org-agenda-category-icon-alist '(("Appointment" "~/.config/emacs/icons/bell.svg" nil nil :ascent center)
                                       ("Cleaning" "~/.config/emacs/icons/house.svg" nil nil :ascent center)
                                       ("Contractor" "~/.config/emacs/icons/tools.svg" nil nil :ascent center)
                                       ("Exercise" "~/.config/emacs/icons/barbell.svg" nil nil :ascent center)
                                       ("Finance" "~/.config/emacs/icons/columns.svg" nil nil :ascent center)
                                       ("Journal" "~/.config/emacs/icons/journal.svg" nil nil :ascent center)
                                       ("Learning" "~/.config/emacs/icons/flask.svg" nil nil :ascent center)
                                       ("Life" "~/.config/emacs/icons/leaf.svg" nil nil :ascent center)
                                       ("Maintenance" "~/.config/emacs/icons/wrench.svg" nil nil :ascent center)
                                       ("Organizing" "~/.config/emacs/icons/folder.svg" nil nil :ascent center)
                                       ("Party" "~/.config/emacs/icons/beer.svg" nil nil :ascent center)
                                       ("Todo" "~/.config/emacs/icons/gears.svg" nil nil :ascent center))
      org-agenda-files '("~/org/tasks/Todo.org")
      org-log-into-drawer "LOGBOOK")
(add-to-list 'org-agenda-custom-commands
               '("x" "Testing tags for negating DONE" tags "-TODO=\"DONE\"" nil nil ))
(define-key org-agenda-mode-map (kbd "M-m") nil)
(global-set-key (kbd "C-o a") 'org-agenda)
#+END_SRC

*** ACTIVE Org-Gantt

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'svg)
(require-package 'ts)
(require 'org-gantt-mode)
#+END_SRC

*** ACTIVE Org Habit

Org habit is useful for recurring todos. The main component to habits is that they be scheduled ideally using the =org-schedule= command (=C-c C-s=), and within that schedule date, before the closing angle bracket, set a reminder interval and an optional due date interval separated by a slash: =.+2d= or =.+2d/4d=.

#+BEGIN_SRC emacs-lisp :padline no
(require 'org-habit)
(setq org-modules '(org-habit))
#+END_SRC

*** ACTIVE Org Journal

One of the things I've always wished I were better at keeping was a journal. Since I use Emacs all of the time, my hope is that making a journal more accessible will help me be more consistent.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'org-journal)
(require 'org-agenda)
(require 'org-journal)
(setq org-journal-date-format "%A, %B %d %Y"
      org-journal-dir "~/org/journal/"
      org-journal-enable-agenda-integration t
      org-journal-file-format "%Y.org"
      org-journal-file-type "yearly"
      org-journal-skip-carryover-drawers t)
(add-to-list 'org-agenda-files org-journal-dir)
(add-to-list 'org-capture-templates `("d" "dream" entry (file "~/org/dreams/Dreams.org")
                                       "* %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n%?"))
(global-set-key (kbd "C-o j") 'org-journal-new-entry)
(add-hook 'org-journal-mode-hook (lambda () (setq truncate-lines t)))
#+END_SRC

*** ACTIVE Org-Roam

Org Roam is great for managing information about things I'm learning about. 

*NOTE:* Org-Roam has [[* Org-Roam Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'org-roam)
(require 'org)
(setq org-roam-capture--file-name-default "%<%Y%m%d>"
      org-roam-completion-system 'ido
      org-roam-capture-templates
      '(("d" "default" plain (function org-roam--capture-get-point)
         "%?"
         :file-name "%<%Y%m%d>-${slug}"
         :head "#+title: ${title}\n"
         :unnarrowed t))
      org-roam-graph-edge-extra-config '(
      ("color" . "green")
      ("fillcolor" . "green"))
      org-roam-graph-extra-config '(
      ("bgcolor" . "lightgray"))
      org-roam-graph-node-extra-config '(
      ("color" . "skyblue")
      ("fillcolor" . "skyblue")
      ("fontname" . "Arial")
      ("style" . "filled")))
(define-key org-mode-map (kbd "C-c i") 'org-roam-insert)
(global-set-key (kbd "C-o r") 'org-roam-capture)
(add-hook 'after-init-hook 'org-roam-mode)
(global-set-key (kbd "C-o f") 'org-roam-find-file)
(global-set-key (kbd "C-o g") 'org-roam-graph)
(global-set-key (kbd "C-o i") 'org-roam-insert)
#+END_SRC

#+BEGIN_SRC emacs-lisp :padline no
(setq org-roam-directory "~/org-roam")
#+END_SRC

#+BEGIN_SRC emacs-lisp :padline no :tangle no
(setq org-roam-directory "~/Documents/WorldApart")
#+END_SRC
**** Org-Roam Dependencies

#+BEGIN_SRC shell
sudo apt install sqlite3
#+END_SRC

*** DISABLED Org-Roam Server

Org-Roam Server provides a novel way of interacting with your Org-Roam files. Most of the appeal is visual to my knowledge, and the functionality it provides is available within Emacs. =org-roam-server-mode= must be called for the server to start.

*NOTE:* Org-Roam Server has [[* Org-Roam Server Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'org-roam-server)
(require 'org-roam-protocol)
(setq org-roam-server-host "127.0.0.1"
      org-roam-server-port 8000
      org-roam-server-authenticate nil
      org-roam-server-export-inline-images t
      org-roam-server-serve-files nil
      org-roam-server-served-file-extensions '("pdf")
      org-roam-server-network-poll t
      org-roam-server-network-arrows nil
      org-roam-server-network-label-truncate t
      org-roam-server-network-label-truncate-length 60
      org-roam-server-network-label-wrap-length 20)
(org-roam-server-mode)
#+END_SRC

**** Org-Roam Server Dependencies

#+BEGIN_SRC shell
sudo apt install graphviz
#+END_SRC

*** ACTIVE Ox-Hugo

Currently, I'm using Ox-Hugo to manage my personal website. Most of the custom configuration for that is in the site's org file as local variables so it doesn't show up here. That site is in a separate repository [[https://gitlab.com/AblatedSprocket/nothingissimple][here]].

*NOTE:* Ox-Hugo has [[* Ox-Hugo Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
  (require-package 'ox-hugo)
  (require 'ox-hugo)
  (add-to-list 'org-capture-templates `("p" "post" entry (file+headline "~/NothingIsSimple/site.org" "Posts")
                                         "* TODO %?\n:PROPERTIES:\n:EXPORT_FILE_NAME: \n:END:\n"))
#+END_SRC

**** Ox-Hugo Dependencies

#+BEGIN_SRC shell
sudo apt install hugo
#+END_SRC

*** ACTIVE Ox-SlimHTML

Currently, I use SlimHTML to export a =links.org= file I keep as my bookmarks. I'm trying out storing my bookmarks in an Org file so I can add notes. I don't know if this is a useful workflow yet so this might go on the chopping block.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'ox-slimhtml)
(require 'ox-slimhtml)
(org-export-define-derived-backend 'custom-html-exporter
    'slimhtml
    :translate-alist
    '((bold . ox-slimhtml-bold)
      (special-block . org-html-special-block)))
#+END_SRC

** Prose

I like using Emacs as a code editor and for creative writing. Emacs doesn't have a lot of the things a standard word processor does (especially by default), but I've found the packages that provide a better experience for me than Word or any other word processor. To use Auctex you need to install a few things:

*NOTE:* Prose has [[* Prose Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
(defun set-printing-font ()
  "Set font to Gentium."
  (face-remap-add-relative 'default '(:family "Gentium")))
#+END_SRC

*** Prose Dependencies

#+BEGIN_SRC shell
sudo apt install fonts-sil-gentium
#+END_SRC

*** ACTIVE Auctex

LaTeX support is provided by Auctex. In general I use Org for writing, but if I need something typeset, Auctex is what I use. I like having =C-c r= point to a run-like function, and generating a preview is about as close to "running" a LaTeX file as you can get in my opinion, so that's what I went with.

*NOTE:* Auctex has [[* Auctex Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'auctex)
#+END_SRC

**** Auctex Dependencies

#+BEGIN_SRC shell
sudo apt install texinfo auctex
#+END_SRC

*** ACTIVE Company-Auctex

I just love Company and want to use it wherever I can. Feel free to disable this.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'company-auctex)
#+END_SRC

*** ACTIVE LaTeX Preview Pane

I like Latex Preview Pane because it's an easy way to get side-by-side LaTeX editing and PDF previewing, as well as error highlighting. Dynamic inline rendering is often spotty as you add more packages, but the pane seems to work well so far.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'latex-preview-pane)
(add-hook 'TeX-mode-hook
          (lambda()
            (local-set-key (kbd "C-c r") 'latex-preview-pane-mode)))
#+END_SRC

*** ACTIVE Langtool

Langtool provides some basic spelling and grammar errors. Presently I'm using Flycheck for spelling, so hopefully this proves better than I'm expecting on the grammar front. This package requires [[https://dev.languagetool.org/http-server][LanguageTool]] and Java. Download the LanguageTool library and extract it to =~/.local/lib/= and install Java.

If you want to use LanguageTool outside of Emacs, the configuration is a little different. I'm debating setting up a Systemd service for LanguageTool and configuring Langtool to use that instead of spinning up its own instance. For now, this works.

*NOTE:* Langtool has [[* Langtool Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'langtool)
(setq langtool-language-tool-server-jar
"~/.local/lib/LanguageTool-5.1/languagetool-server.jar")
#+END_SRC

**** Langtool Dependencies

#+BEGIN_SRC shell
sudo apt install openjdk-14-jre-headless
#+END_SRC

*** ACTIVE Merriam-Webster Thesaurus

This marks an important milestone for my view to how I write. This is something I always wanted. I always hated having to break my immersion in my writing to go to a browser to look up a synonym for something. I haven't used this extensively yet, but I think it will make a huge difference for me. 

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'mw-thesaurus)
(define-key org-mode-map (kbd "C-c h") 'mw-thesaurus-lookup-at-point)
#+END_SRC

*** ACTIVE Olivetti

Some parts of a standard word processor I missed until I learned about Olivetti. I mostly wanted the document centered on the page with a fixed width. I'm still exploring its capabilities, but if more is desired, Olivetti might not be the way to go.

I like the idea of keeping code and more creative writing separate, so I wanted a font to enforce that separation.

I kind of fiddled around with different widths in Olivetti mode to see what felt right for a typical document. I go back and forth on which file types to trigger Olivetti on. I've put in Markdown and org, but those don't feel right a lot of the time. I always go back to plain old .txt files, though.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'olivetti)
(require 'olivetti)
(setq olivetti-body-width 77)
(add-to-list 'auto-mode-alist '("\\.txt\\'" . olivetti-mode))
(add-hook 'olivetti-mode-hook
         (lambda()
           (setq display-line-numbers nil)))
(add-hook 'olivetti-mode-hook 'set-printing-font)
(add-hook 'olivetti-mode-hook 'flyspell-mode)
(add-hook 'olivetti-mode-hook (lambda ()
  (setq olivetti-body-width 84)))
#+END_SRC

*** DISABLED LSP-LaTeX

*NOTE:* LSP-LaTeX has 
#+BEGIN_SRC emacs-lisp :padline no
(require-package 'lsp-latex)
#+END_SRC

**** LSP-LaTeX Dependencies

Requires installing TeXLab. Releases can be found [[https://github.com/latex-lsp/texlab/releases][here]]. Extract the file and copy to =~/.local/bin/=.

** ACTIVE Code Configuration


For code, =toggle-comment-on-line= has been an invaluable function that I use all of the time as a keybinding. I have the various binaries that Emacs needs access to for programming languages (for linting, LSP connections, etc) installed at =~/.local/bin=, so I have those settings set up here.

#+BEGIN_SRC emacs-lisp :padline no
(defun toggle-comment-on-line ()
  "Comment or uncomment current line."
  (interactive)
  (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
(add-to-list 'exec-path "~/.local/bin")
(setenv "PATH" (concat "~/.local/bin:" (getenv "PATH")))
(define-key prog-mode-map (kbd "C-c h") 'hs-toggle-hiding)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
(add-hook 'prog-mode-hook 'hl-line-mode)
(add-hook 'prog-mode-hook 'hs-minor-mode)
(add-hook 'prog-mode-hook (lambda ()
                            (setq indent-tabs-mode nil)))
#+END_SRC

*** ACTIVE Blacken

Currently, I use Blacken for Python code formatting.

*NOTE:* Assumes you have installed packages for [[* Python Dependencies][Python]].

*NOTE:* Blacken has [[* Blacken Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'blacken)
(require 'blacken)
(require 'python)
(define-key python-mode-map (kbd "C-c f") 'blacken-buffer)
#+END_SRC

**** Blacken Dependencies

#+BEGIN_SRC shell
pip3 install black
#+END_SRC

*** DISABLED Debug Adapter Protocol
#+BEGIN_SRC emacs-lisp :padline no
(require-package 'dap-mode)
(require 'dap-gdb-lldb)
#+END_SRC
*** ACTIVE LSP-Pyls

Python language server provides the backend for LSP-mode. The one thing I dislike about Python and pep8 in general is the "line too long" suggestions. 

*NOTE* Assumes you have installed packages for [[* Python Dependencies][Python]]

*NOTE* LSP-Pyls has [[* LSP-Pyls Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
(setq lsp-pyls-plugins-pycodestyle-ignore '("E501"))
#+END_SRC

**** LSP-Pyls Dependencies

#+BEGIN_SRC shell
pip3 install 'python-language-server[all]'
#+END_SRC

*** ACTIVE HL-Todo

HL-Todo highlights to-do items in buffers where the mode is active. Previously, I used a package called FIC mode, which is supposed to only highlight to-dos in strings and comments but it didn't work as advertised.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'hl-todo)
(require 'hl-todo)
(add-hook 'prog-mode-hook 'hl-todo-mode)
#+END_SRC

*** ACTIVE LSP

So far, I use Python and Rust in Emacs, both of which have good LSP options. Because of this, I have a section for general, LSP-oriented configuration and separate sections for each language that is supported by the LSP mode umbrella. 

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'lsp-mode)
(require 'lsp-mode)
;; Previously this required with-eval-after-load lsp
(setq lsp-modeline-diagnostics-scope :project
      lsp-signature-doc-lines 1)
(define-key lsp-mode-map (kbd "C-c a") 'lsp-execute-code-action)
(define-key lsp-mode-map (kbd "C-c d") 'lsp-describe-thing-at-point)
(define-key lsp-mode-map (kbd "C-c s") 'rg)
(define-key lsp-mode-map (kbd "C-c e") 'lsp-rename)
(define-key lsp-mode-map (kbd "C-c S") 'lsp-treemacs-symbols)
#+END_SRC

*** ACTIVE LSP-Treemacs

I haven't actually used Treemacs-Magit yet. It was a package I read about and was convinced I needed. I am only just starting to get comfortable with Magit after spending many months using the CLI. I imagine I will have more to say about Treemacs-Magit soon.
I have found LSP-Treemacs pretty useful. I like being able to see all of the symbols in a project, similar to the Object Explorer in Visual Studio.
#+BEGIN_SRC emacs-lisp :padline no
(require-package 'lsp-treemacs)
#+END_SRC

*** ACTIVE Magit

I am not sure if Magit should be in this section or a more general configuration section. I'm seeing more and more places outside of code where source control would be useful.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'magit)
#+END_SRC

*** ACTIVE MHTML

MHTML is par for every other package I've used for HTML templates. I don't have any real configuration for it, just a bunch of snippets.

#+BEGIN_SRC 
(add-hook 'mhtml-mode-hook 'toggle-truncate-lines)
#+END_SRC

*** ACTIVE OB-Restclient

OB-Restclient has been a joy to use. If it were up to me, I would never use Postman again. Incorporating literate programming into test suites is amazing, especially when you can mix Restclient with your programming langauge of choice. I'm debating using Org-Babel to add literate programming to all of my source code and tangling it out for compiling and running. My only reservation with this is that this is not commonplace, meaning 1) I would have to live without it on projects that I don't own and 2) anyone who might want to contribute to a project of mine would have to deal with org-babel-tangle.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'ob-restclient)
(require 'restclient)
(org-babel-do-load-languages 'org-babel-load-languages '((restclient .t)))
#+END_SRC

*** ACTIVE Python

If you are not interested in Python development, you can set the state of all subheadings to =DISABLED= with no side-effects. If you are interested, this configuration uses Python 3. Currently my system is using Python 3.8.

For the most part, the keybindings I like for Python development are covered by LSP, so the only thing here, really, are Electric-Pair completions. Even those are pretty universal and probably better suited for the general code settings section. In order to use Emacs for Python you will of course need Python and pip:

*NOTE:* Python has [[* Python Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
(require 'python)
(define-key python-mode-map "'" 'electric-pair)
(define-key python-mode-map "\"" 'electric-pair)
(define-key python-mode-map "(" 'electric-pair)
(define-key python-mode-map "[" 'electric-pair)
(define-key python-mode-map "{" 'electric-pair)
(add-hook 'python-mode-hook 'lsp)
#+END_SRC

**** Python Dependencies

#+BEGIN_SRC shell
sudo apt install python3.8 python3-pip
#+END_SRC

*** ACTIVE Pyvenv

I use Pyvenv to interface with my projects' virtual environments. 

*NOTE:* Assumes you have installed packages for [[* Python Dependencies][Python]].

*NOTE:* Pyvenv has [[* Pyvenv Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'pyvenv)
(setq pyvenv-default-virtual-env-name "venv")
(define-key python-mode-map (kbd "C-c r")
   (lambda()
     (interactive)
     (compile (concat "venv/bin/python3 " (buffer-name)))))
(add-hook 'python-mode-hook 'pyvenv-mode)
#+END_SRC

**** Pyvenv Dependencies

#+BEGIN_SRC shell
sudo apt install python3-venv
#+END_SRC

*** ACTIVE Rainbow Delimiters

For me, Rainbow Delimiters has saved me a lot of time tracking down parentheses and brackets in Rust and the little elisp I am willing to commit to.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'rainbow-delimiters)
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

*** ACTIVE Restclient

I'm hoping to use Restclient as a stand-in for Postman. I found an integration with Org-Babel that has been great to use. For me, Org-Babel is a must for Restclient.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'restclient)
(require 'restclient)
#+END_SRC

*** ACTIVE Rust

Development for Rust is pretty low-level at this point. If you're not interested in Rust development, you can change the state of the below subheadings to =DISABLED= with no side-effects.

*NOTE:* Rust has [[* Rust Dependencies][dependencies]].

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'rust-mode)
(require 'rust-mode)
(require 'lsp-mode)
(defun cargo-build (arg)
  "Build with input ARG."
  (interactive "MCargo Build arguments: ")
  (compile (concat "cargo build " arg)))
(add-to-list 'exec-path "~/.cargo/bin")
(setenv "PATH" (concat "~/.cargo/bin:" (getenv "PATH")))
(setq lsp-rust-analyzer-server-display-inlay-hints t
      lsp-rust-analyzer-server-command '("~/.local/bin/rust-analyzer")
      lsp-rust-server 'rust-analyzer)
(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
(define-key rust-mode-map "\"" 'electric-pair)
(define-key rust-mode-map "(" 'electric-pair)
(define-key rust-mode-map "[" 'electric-pair)
(define-key rust-mode-map "{" 'electric-pair)
(define-key rust-mode-map "<" 'electric-pair)
(define-key rust-mode-map (kbd "C-c b") 'cargo-build)
(define-key rust-mode-map (kbd "C-c f") 'rust-format-buffer)
(define-key rust-mode-map (kbd "C-c r")
  (lambda ()
    (interactive)
    (compile "cargo run")))
(define-key rust-mode-map (kbd "C-c k")
  (lambda ()
    (interactive)
    (compile "cargo check")))
(define-key rust-mode-map (kbd "C-c t")
  (lambda ()
    (interactive)
    (compile "cargo test -- --nocapture")))
(define-key rust-mode-map (kbd "C-c C-f") nil)
(add-hook 'rust-mode-hook 'lsp)
#+END_SRC

**** Rust Dependencies
If you are interested in Rust, the first thing you should do is install [[https://www.rust-lang.org/tools/install][Rust]]. Once that's done, install Rust-Analyzer by cloning the repository:

#+BEGIN_SRC shell
git clone https://github.com/rust-analyzer/rust-analyzer.git
cd rust-analyzer
cargo xtask install --server
#+END_SRC

Now you should see the =rust-analyzer= binary under =~/.cargo/bin/=. Make sure Emacs knows about the path by adding the =add-to-list= and =setenv= configuration items in your [[* Rust][Rust]] config.

To enable various IDE features, you will want to install =rust-src=:

#+BEGIN_SRC shell

rustup component add rust-src
#+END_SRC

*** ACTIVE Rust Flycheck

Rust Flycheck provides syntax highlighting. I need to make sure this is required.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'flycheck-rust)
(require 'flycheck)
(require 'flycheck-rust)
(add-hook 'rust-mode-hook 'flycheck-rust-setup)
#+END_SRC

*** ACTIVE Treemacs-Magit

I haven't had the opportunity to use this extensively yet. Since I'm just getting used to Magit, I'm wondering if this will come in handy. It might not.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'treemacs-magit)
#+END_SRC

** ACTIVE SQL Client Configuration

My configuration also provides some customization of Emacs' SQL mode. My workflow for SQL usually consists of two buffers: one of a SQL file and the other is the SQL interactive buffer. The SQL file is helpful because I can save and track my queries easily without thinking about it and the keeping the SQLi buffer separate is nice because I can disable font-lock so query results don't have silly distracting faces. The first function disables font-lock for SQL Interactive mode and the second sets up the SQL Interactive-mode buffer automatically when SQL mode is enabled (either by opening a SQL buffer or manually activating SQL mode). Here, I've set up a list of connections I use frequently. I was surprised by how much of a quality-of-life improvement this was. I made a couple of keybindings for sending region and the whole buffer to the SQL Interactive mode buffer. I believe there are existing bindings for this, but I wanted something more in keeping with the rest of my keybinding setup. 

#+BEGIN_SRC emacs-lisp :padline no
(require 'sql)
(defun my-sql-disable-font-lock (orig-fun &rest args)
  "Disable syntax highlighting for SQL output."
  (cl-letf (((symbol-function #'sql-product-font-lock) #'ignore))
    (apply orig-fun args)))
(defun my-sql-login-hook ()
  "Custom SQL log-in behaviors."
  (when (eq sql-product 'postgres)
    (let ((proc (get-buffer-process (current-buffer))))
      (comint-send-string proc "\\set ECHO queries\n"))))
(setq sql-connection-alist
      '(
        (home (sql-product 'postgres)
              (sql-port 5432)
              (sql-server "localhost")
              (sql-user "postgres")
              (sql-database "savetheglobe"))
        (savetheglobe_home (sql-product 'postgres)
                           (sql-port 5432)
                           (sql-server "localhost")
                           (sql-user "postgres")
                           (sql-database "savetheglobe"))
        (savetheglobe_heroku (sql-product 'postgres)
                             (sql-port 5432)
                             (sql-server "ec2-52-87-22-151.compute-1.amazonaws.com")
                             (sql-user "nrsgquqvfevzbu")
                             (sql-database "ddpfocn81le95m"))))

(define-key sql-mode-map (kbd "C-c r") 'sql-send-region)
(define-key sql-mode-map (kbd "C-c R") 'sql-send-buffer)
(advice-add 'sql-interactive-mode :around 'my-sql-disable-font-lock)
(add-hook 'sql-mode-hook 'sql-set-sqli-buffer)
(add-hook 'sql-mode-hook '(lambda ()
                            (setq truncate-lines t
                                  word-wrap nil)))
;; (add-hook 'sql-login-hook 'my-sql-login-hook)
#+END_SRC

** ACTIVE SQLUp

SQLUp up-cases SQL keywords. I liked this in SSMS and enjoy having it in Emacs as well.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'sqlup-mode)
(require 'sql)
(add-hook 'sql-mode-hook 'sqlup-mode)
(add-hook 'sql-interactive-mode-hook 'sqlup-mode)
#+END_SRC

** Work

Integrations with Jira and Slack

*** DISABLED Ejira

I'm working on a couple of programming projects outside of work, one with another person. He wanted to use Jira, and I noticed that there are a couple of Jira integrations for Emacs, Org-Jira and Ejira. I chose Ejira because it takes advantage of Jira's REST API, as opposed to Org-Jira which is SOAP-based. It's much easier for me to debug JSON payloads as opposed to XML. Currently, the Ejira files are included with my config for two reasons: one is that Ejira is not on MELPA yet, and the second is that there's some deal-breaking functionality missing from the maintained branch, mostly mentioning users.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'cl-lib)
(require-package 'dash)
(require-package 'dash-functional)
(require-package 'language-detection)
(require-package 'ox-jira)
(require-package 's)
(require 'ejira)
(setq jiralib2-url "https://jasonandandybuildsomething.atlassian.net"
      jiralib2-auth 'token
      jiralib2-user-login-name "andrewwburch@gmail.com"
      jiralib2-token (auth-source-pick-first-password
                      :host "jasonandandybuildsomething.atlassian.net"
                      :user "andrewwburch@gmail.com")
      ejira-org-directory "~/.jira"
      ejira-projects '("SB")
      ejira-priorities-alist '(("Highest" . ?A)
                               ("High"    . ?B)
                               ("Medium"  . ?C)
                               ("Low"     . ?D)
                               ("Lowest"  . ?E))
      ejira-todo-states-alist '(("To Do"  . 1)
                                ("Doing" . 2)
                                ("Test"  . 3)
                                ("Done"  . 4))
      ejira-org-todo-keywords-alist '(("SB" . ("TODO"
                                             "DOING"
                                             "TEST"
                                             "DONE")))
      org-id-track-globally t)
#+END_SRC

*** DISABLED Slack

I've proofed out this slack integration and got it to a working state.

#+BEGIN_SRC emacs-lisp :padline no
(require-package 'slack)
(require 'slack)
(setq slack-prefer-current-team t)
(slack-register-team
  :name "Team Engineer"
  :default t
  :token (auth-source-pick-first-password
          :host "teamengineer.slack.com"
          :user "andrewwburch@gmail.com"))
(slack-start)
#+END_SRC
*** DISABLED Discord
**** Discord Dependencies

First install Bitlbee:

#+BEGIN_SRC shell :padline no
sudo apt install bitlbee-dev
#+END_SRC

Then, Bitlbee-Discord needs to be installed from [[https://github.com/sm00th/bitlbee-discord][source]].
